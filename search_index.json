[["index.html", "Manual de R Descripción", " Manual de R Rubén Darío Jaramillo (rubend18@hotmail.com) 2021-12-12 Descripción El objetivo de este manual es introducir en el conocimiento del Lenguaje R. Se analizan con detalle los mecanismos y las funciones que el lenguaje proporciona para al análisis y visualización de datos. Se revisan los mecanismos para representar visualmente los datos a través de funciones como plot, hist o boxplot. "],["compilación.html", "Compilación", " Compilación La información de la sesión R al compilar este libro se muestra a continuación: sessionInfo() ## R version 4.1.2 (2021-11-01) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 8.1 x64 (build 9600) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Spanish_Ecuador.1252 LC_CTYPE=Spanish_Ecuador.1252 ## [3] LC_MONETARY=Spanish_Ecuador.1252 LC_NUMERIC=C ## [5] LC_TIME=Spanish_Ecuador.1252 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] bookdown_0.24 digest_0.6.28 R6_2.5.1 jsonlite_1.7.2 ## [5] magrittr_2.0.1 evaluate_0.14 stringi_1.7.5 rlang_0.4.12 ## [9] rstudioapi_0.13 jquerylib_0.1.4 bslib_0.3.1 rmarkdown_2.11 ## [13] tools_4.1.2 stringr_1.4.0 xfun_0.28 yaml_2.2.1 ## [17] fastmap_1.1.0 compiler_4.1.2 htmltools_0.5.2 knitr_1.36 ## [21] sass_0.4.0 "],["introducción-a-r.html", "Capítulo 1 Introducción a R", " Capítulo 1 Introducción a R Introducción y objetivos El objetivo fundamental de este tema es servir como presentación y primera toma de contacto con R. Para cumplir con este objetivo comenzaremos con una breve introducción en la que definiremos qué es R, veremos cuál es su origen y presentaremos algunos argumentos que apoyarían la utilización de R como herramienta de análisis de datos. A continuación procederemos a instalar el entorno de R en un ordenador y comenzaremos a trabajar con este entorno de una manera más práctica. Así, cuando hayas finalizado con los contenidos de este tema: Habrás aprendido qué es R y cuáles son sus orígenes. Conocerás algunas de las ventajas que ofrece el uso de R como herramienta de análisis de datos. Habrás instalado R en tu ordenador. Serás capaz de utilizar la consola de R para ejecutar los primeros comandos en el entorno. Sabrás cómo se puede automatizar la ejecución de toda una serie de comandos mediante el uso de scripts sencillos. "],["qué-es-r.html", "1.1 ¿Qué es R?", " 1.1 ¿Qué es R? Podemos definir R desde dos perspectivas distintas: R es un entorno software R es un lenguaje de programación Fundamentalmente R puede ser definido como un entorno software para el análisis matemático y estadístico de datos, en cierto sentido similar a herramientas tales como Microsoft Excel. A través del entorno de R vamos a ser capaces de manipular datos (por ejemplo, cargarlos desde ficheros, editarlos, volverlos a almacenar, etc.), realizar análisis sobre esos datos y presentar los resultados gráficamente para facilitar su interpretación. El entorno software viene acompañado de un lenguaje de programación que pone a nuestra disposición las funcionalidades típicas de un lenguaje de propósito general (manejo de variables, tipos y estructuras de datos, operadores, mecanismos de control del flujo de ejecución, funciones, etc.) combinadas con librerías y herramientas específicas para facilitar el análisis de datos. Como veremos, utilizando este lenguaje es relativamente sencillo implementar nuestras propias funciones y scripts para automatizar el procesamiento de ciertos datos. En la práctica, estas dos perspectivas están muy relacionadas, así por ejemplo para interactuar con el entorno de R utilizaremos expresiones escritas en el lenguaje R. En este tema haremos una breve introducción que sirva de toma de contacto con el entorno software de R, dejando para temas siguientes el estudio más detallado del lenguaje de programación. "],["orígenes-y-antecedentes.html", "1.2 Orígenes y antecedentes", " 1.2 Orígenes y antecedentes Para conocer los antecedentes del lenguaje R tenemos que remontarnos a los años 70. En aquella época, el mecanismo habitualmente utilizado a la hora de llevar a cabo análisis matemático y estadístico de datos consistía en la implementación de rutinas específicas. Para desarrollar estas rutinas se utilizaba fundamentalmente el lenguaje Fortran, que había sido específicamente creado por IBM en los años 50 para facilitar la computación matemática y científica. En el año 1976 un grupo de cinco personas que trabajaban en los Laboratorios Bell, Rick Becker, John Chambers, Doug Dunn, Paul Tukey, y Graham Wilkinson, comenzaron el desarrollo de un lenguaje y un sistema específico para el análisis de datos, al que se denominó S. Con respecto al paradigma clásico basado en rutinas específicas, lo que se pretendía conseguir con S es disponer de un mecanismo más simple e interactivo para el análisis de datos, que permitiera la programación cuando fuese necesaria (por ejemplo, a la hora de hacer nuevos desarrollos de métodos estadísticos) pero que no la hiciese obligatoria para el análisis rutinario de datos. R nace como una implementación gratuita y de código libre del lenguaje y sistema S. El proyecto fue iniciado a mediados de los años 90 por Ross Ihaka y Robert Gentleman, en la Universidad de Auckland, aunque actualmente el desarrollo de R corre a cargo del R Development Core Team. "],["por-qué-r.html", "1.3 ¿Por qué R?", " 1.3 ¿Por qué R? Actualmente existe una amplia gama de herramientas que podríamos pensar en utilizar a la hora de llevar a cabo análisis de datos (como por ejemplo Microsoft Excel, S-PLUS, una versión comercial del lenguaje S, SAS, SPSS de IBM, etc.). Así pues, una de las cuestiones que nos podríamos plantear en este tema es por qué elegir R como herramienta de análisis de datos. Algunas de las razones que podríamos esgrimir a la hora de justificar nuestra decisión incluyen: R es software de código libre con licencia GNU GPL (General Public License). Mientras que las principales herramienta de análisis son de pago, R es completamente gratuito. Existen versiones para los sistemas operativos más comunes: Windows, Mac OS X y Linux. Posee una comunidad de usuarios amplia y muy activa, con lo que va a resultar relativamente sencillo encontrar documentación o ayuda en foros si resulta necesario. El entorno es fácilmente extensible, mediante el desarrollo de paquetes. Debido a esto, evoluciona rápidamente: nuevos algoritmos y técnicas de análisis se incorporan con regularidad. R y sus extensiones nos ofrece una gran variedad de herramientas de análisis y visualización de datos. A la hora de redactar este documento existían más de 8.000 paquetes disponibles para ser instalados en el entorno. "],["instalación-del-entorno-de-r.html", "1.4 Instalación del entorno de R", " 1.4 Instalación del entorno de R Como mencionamos anteriormente, una de las principales ventajas que nos ofrece R es que se trata de una herramienta de código libre, que ha sido portada a los principales sistemas operativos de usuario actualmente existentes: Windows, Mac OS X y Linux. Figura 1. Logotipo R En esta sección veremos brevemente cómo podemos instalar R en estos sistemas operativos. Trabajaremos con la última versión disponible de la plataforma, que en el momento de escribir este documento es la 3.3.1, publicada en junio de 2016. Dado que R evoluciona con cierta rapidez, es posible que cuando leas este documento exista una nueva versión disponible. Si es así, puedes utilizarla. En todo caso, el proceso de instalación no ha cambiado demasiado en los últimos tiempos, así que la información proporcionada en esta sección te será probablemente de utilidad. Aunque R es una herramienta de código libre y, por tanto, es posible hacer la instalación a partir del código fuente, el mecanismo más habitual es utilizar paquetes binarios de instalación disponibles para los distintos sistemas operativos. Ese será el mecanismo que nosotros utilizaremos. 1.4.1 Instalación en Windows y Mac OS X Para poder instalar R en cualquiera de estos dos sistemas utilizaremos un mecanismo muy similar, por eso se comentarán en el mismo apartado. El primer paso es descargar el instalador específico de nuestra plataforma. Accede al instalador a través del sitio web del proyecto R: http://www.r-project.org/ Figura 2. La página principal del proyecto R. Una vez allí, veremos que en la parte izquierda de la pantalla aparece un enlace al área de descargas, con el texto CRAN, acrónimo de «Comprehensive R Archive Network». CRAN es una red de servidores web y FTP distribuidos por todo el mundo que actúan como réplicas o servidores espejo (mirrors) para la distribución del software y la documentación de R. Si hacemos clic en ese enlace, veremos que aparece una página web conteniendo la lista de servidores de la red CRAN desde los que poder descargar el software. Figura 3. Listado de servidores de la red CRAN. Esta lista está organizada geográficamente, de forma que usualmente los usuarios escogerán aquel servidor que se encuentre más próximo a su ubicación, porque es probable que también se encuentre más cerca en Internet y, por tanto, los tiempos de descarga serán menores. Una vez seleccionado el servidor de descarga, veremos que aparece una nueva página, en cuya parte superior aparecen enlaces específicos para cada sistema operativo. Veremos también que desde esta página tenemos acceso al código fuente de la herramienta, en caso de que queramos realizar la instalación a partir de él (aunque esta práctica no se recomienda en el caso de usuarios de Windows o Mac OS X, puesto que el proceso de instalación a partir de las fuentes es bastante más complejo que el basado en usar el instalador). Figura 4. Página de descargas. Así que simplemente debemos seleccionar el enlace más adecuado para nuestro sistema. En el caso de Mac OS X, la página que visitamos ya contiene el binario del instalador y algunas instrucciones relacionadas. En el caso de Windows, aún pasaremos a través de una página intermedia, en la que nos pedirá que seleccionemos qué es exactamente lo que queremos descargar: si el sistema base, los paquetes de extensión (contributed packages) u otras herramientas. En nuestro caso, seleccionaremos el sistema base. A continuación, descargaremos el instalador y lo ejecutaremos en nuestro sistema haciendo doble clic. El proceso de instalación requiere que aceptemos la licencia y proporcionemos alguna información de configuración (como por ejemplo, el directorio en el que deseamos instalar el software), aunque se recomienda mantener la configuración por defecto. 1.4.2 Instalación en Linux En el caso de Linux el proceso de instalación es ligeramente distinto, puesto que el mecanismo habitual es utilizar los gestores de paquetes que usualmente acompañan a las distribuciones de este sistema operativo. Para ello necesitaremos además permisos adecuados (bien realizando la instalación con el usuario root o utilizando el comando sudo). Aunque existen múltiples distribuciones Linux (como por ejemplo Debian, Red Hat, SUSE, etc.) en esta sección veremos brevemente el proceso de instalación en Ubuntu, una de las más conocidas y populares. Las versiones recientes de Ubuntu ya incluyen una distribución de R que se puede instalar con relativa facilidad empleando alguna herramienta de gestión de paquetes. En nuestro caso, usaremos la herramienta APT (Advanced Packaging Tool) y seguiremos los siguientes pasos: Es recomendable comenzar indicando al gestor de paquetes que actualice su configuración (listado de paquetes disponibles para instalación). Para ello, ejecutaremos el commando en el terminal: sudo apt-get update Una vez configurado el gestor de paquetes, podemos proceder a utilizarlo para instalar todo lo necesario, ejecutando para ello en el terminal: sudo apt-get install r-base r-base-dev "],["primeros-pasos-con-r.html", "1.5 Primeros pasos con R", " 1.5 Primeros pasos con R Tras haber seguido los pasos indicados en la sección anterior, deberíamos tener correctamente instalado el entorno R en nuestro sistema. En Windows y Mac OS X, como resultado de la instalación se creará un icono (que usualmente en Windows estará en el escritorio y en Mac OS X accesible a través del Launchpad) en el que al hacer clic lanzaremos el entorno de ejecución de R. Al lanzar el entorno de ejecución en Windows y Mac OS X aparecerá una ventana. Esta ventana nos ofrecerá una consola (R console) que utilizaremos para poder interactuar con el entorno de R. La consola de R funciona de una manera similar a la de un intérprete de comandos de un sistema operativo clásico: teclearemos ahí nuestros comandos (denominados expresiones en R) y obtendremos a través de ella los resultados (incluyendo mensajes de error si algo va mal). Figura 5. Ejemplo de consola de R (en Mac OS X). En Linux, para poder acceder a esta consola simplemente será necesario ejecutar en el intérprete de comandos del sistema operativo la orden R (en mayúsculas). En este caso no aparecerá una nueva ventana, sino que usaremos la ventana del intérprete de comandos como consola de R. En la consola podemos ver que existe una marca (denominada prompt), que usualmente es el símbolo de mayor que (&gt;) y que nos indica que el sistema está esperando a que tecleemos nuestros comandos. Veremos en las siguientes secciones algunos comandos básicos con los que empezar a trabajar con R en la práctica. 1.5.1 Realizando operaciones basicas La forma más sencilla de empezar a trabajar con R, es utilizando el software como si de una calculadora avanzada se tratase. Simplemente tendremos que escribir la expresión que queramos evaluar en la consola y pulsar la tecla de fin de línea (enter). R nos devolverá el resultado impreso en la consola. Por ejemplo, para sumar dos números: 2+3 # [1] 5 Aunque se pueden llevar a cabo todo tipo de operaciones aritméticas: 2*3 # [1] 6 2/3 # [1] 0.6666667 2^3 # [1] 8 2**3 # [1] 8 3%%2 # [1] 1 (2.2+3.5)*2.1 # [1] 11.97 1+2+3-4 # [1] 2 5%/%2 # [1] 2 Como se puede ver, las operaciones básicas utilizan los operadores habitualmente empleados en los lenguajes de programación (+, -, *, /), teniendo en cuenta que en el caso del operador módulo (resto de la división entera de dos números) se utiliza %% (cuando lo más usual en otros lenguajes es usar %), que es posible realizar potenciación tanto con el carácter ^ como con el doble asterisco ** y que si queremos que la operación de división trate a sus argumentos como números enteros, deberemos utilizar el operador %/%. También resulta interesante comprobar qué pasa cuando realizamos operaciones que resultan en un indeterminado o en infinito: 2/0 # [1] Inf Inf/Inf # [1] NaN 0/0 # [1] NaN -Inf/2 # [1] -Inf Como se puede ver este tipo de operaciones están soportadas en el entorno de R pudiendo utilizarse el símbolo Inf para referirse a infinito y NaN (Not a Number) para referirse a valores indeterminados. 1.5.2 Llamando a funciones Además de los operadores básicos, R proporciona todo un conjunto de funciones que podemos utilizar en nuestras expresiones. Básicamente la llamada a funciones desde la consola de R funciona de una manera similar a la de cualquier lenguaje de programación: proporcionaremos el nombre de la función y sus argumentos y obtendremos su resultado impreso en consola. Veamos algunos ejemplos: exp(1) # [1] 2.718282 log(exp(1)) # [1] 1 log10(10) # [1] 1 log2(2) # [1] 1 sqrt(4) # [1] 2 cos(pi) # [1] -1 sin(pi) # [1] 1.224647e-16 tan(pi) # [1] -1.224647e-16 abs(-2.4) # [1] 2.4 ceiling(-2.4) # [1] -2 floor(-2.4) # [1] -3 round(-2.3894, 1) # [1] -2.4 Donde quizás nos llamen la atención algunas cosas: el uso del símbolo pi para referirse a la constante del mismo nombre, que existen distintas funciones para operar con el logaritmo dependiendo de su base (log -para calcular el logaritmo natural o neperiano-, log2 y log10) o que la operación seno de pi, que debería devolver un cero, en la práctica nos devuelve un valor distinto a cero, pero muy pequeño (epsilon). También es posible pasar argumentos a funciones utilizando explícitamente los nombres de dichos argumentos, en lugar de la posición. Así por ejemplo, si vemos la documentación de la función round (se presenta en la siguiente sección cómo hacer esto) observaremos que recibe dos argumentos. El primer argumento (denominado x) es el número a redondear, mientras que el segundo argumento (denominado digits) indica el número de decimales que deseamos preservar al hacer el redondeo. Sabiendo esto, podemos invocar a esta función no solo con los parámetros en orden (como en los ejemplos anteriores), sino también por ejemplo como: round(-2.3894, digits=1) # [1] -2.4 round(digits=1, x=-2.3894) # [1] -2.4 1.5.3 Accediendo a la ayuda de R Es posible que en algún momento queramos trabajar con alguna función y no recordemos exactamente cuál es su nombre, o no sepamos cómo utilizarla (por ejemplo, qué argumentos recibe). Para resolver este tipo de problemas podemos echar mano de la ayuda de R. En particular, dos funciones de ayuda resultan especialmente útiles: La función apropos, que se utiliza para encontrar nombres de funciones u otros elementos a partir de una cadena de texto que queremos buscar (para indicar que el argumento es una cadena de texto, usaremos comillas simples o dobles). Por ejemplo: apropos(&quot;round&quot;) # [1] &quot;round&quot; &quot;round.Date&quot; &quot;round.POSIXt&quot; La función help que nos permite acceder a la ayuda de R. Por ejemplo, si ejecutamos en la consola de R la expresión help(cos) (o simplemente ?cos) veremos aparecer una ventana emergente como la que se muestra en la figura a continuación: Figura 6. Ventana de ayuda de R. Además podemos acceder a la documentación de R simplemente tecleando en la consola la expresión help.start() esto debería abrir un navegador donde podremos navegar a través de la documentación en formato HTML. 1.5.4 Trabajando con variables En algunas ocasiones, cuando estemos realizando una serie de operaciones en la consola de R, necesitaremos poder almacenar resultados intermedios para poder referirnos a ellos en operaciones futuras. Para poder hacer esto, utilizaremos variables que se definen con un nombre y un valor, de forma que podamos acceder en el futuro al valor a partir del nombre. Al decidir nuestros nombres de variables en R tenemos que tener en cuenta las reglas de nombramiento de símbolos de R: R distingue entre mayúsculas y minúsculas. Usualmente se permite utilizar toda clase de símbolos alfanuméricos (incluyendo caracteres acentuados, ñ, etc.) además del punto «.» y del guion bajo «_». Eso sí, los nombres deben empezar por «.» o por una letra y si empiezan por «.» entonces el segundo carácter no debería ser un número. El entorno no impone límites a la longitud de los nombres de los símbolos (aunque por motivos prácticos no deberíamos hacerlos demasiado largos). Para poder definir una variable y asignarle un valor, utilizaremos el operador de asignación. Aunque el signo de igualdad (=) esta soportado como operador de asignación en versiones recientes de R, lo mas habitual es emplear en las asignaciones el simbolo &lt;- (denominado gets), por ejemplo: x&lt;-2 x+3 # [1] 5 log2(x) # [1] 1 x # [1] 2 Nótese que para poder obtener el valor de una variable por consola, simplemente teclearemos su nombre seguido de un fin de línea. Si en un determinado momento no recordamos qué variables hemos definido, es sencillo obtener un listado de las variables declaradas utilizando la función ls: x&lt;-2 y&lt;-6 ls() # [1] &quot;x&quot; &quot;y&quot; También es posible borrar una variable que hemos definido previamente, simplemente utilizando la función rm: x&lt;-2;y&lt;-6 ls() # [1] &quot;x&quot; &quot;y&quot; rm(x) ls() # [1] &quot;y&quot; En este ejemplo se puede ver también que hemos utilizado la posibilidad de combinar varias expresiones en una simple línea (a la hora de asignar valores a x e y), separándolas mediante punto y coma. 1.5.5 Instalación de paquetes Como comentamos con anterioridad, una de las ventajas que ofrece el entorno R es que es fácilmente extensible por medio de un mecanismo de paquetes. Actualmente existen más de 8.000 paquetes disponibles para su instalación, lo que permite que en R podamos encontrar implementaciones para casi cualquier clase de técnica de análisis de datos que se nos ocurra. Sin embargo, estos paquetes no suelen formar parte por defecto del entorno R, así que será necesario instalarlos manualmente cuando los necesitemos. Normalmente el proceso para utilizar un paquete requiere de los siguientes pasos: Buscar el paquete que implementa la funcionalidad necesaria, bien utilizando buscadores horizontales, como Google, bien con buscadores verticales como podría ser Crantastic o Rseek. También podrían ser de ayuda en este sentido portales específicos como R-Forge o Bioconductor (este último centrado en aplicaciones en el dominio de la Biología). Una vez sabemos el nombre del paquete a utilizar, lo instalaremos utilizando la función install.packages. Por ejemplo, si queremos instalar un paquete denominado digest ejecutaríamos en la consola de R la expresión: install.packages(&quot;digest&quot;, dependencies=TRUE) Que como podemos ver indica el nombre del paquete a instalar y establece que se instalen también otros paquetes de los que pueda depender este. Como resultado de ejecutar esta expresión, aparecerá una ventana que nos permitirá seleccionar el servidor CRAN desde el que queremos hacer la instalación: Figura 7. Ventana de selección de servidor CRAN (Mac OS X). Una vez seleccionado el servidor, y siempre que nuestra versión de R sea compatible con la versión para que el paquete fue implementado, el sistema procederá a la descarga e instalación de todo lo necesario. Cuando el paquete está ya instalado, tenemos que decirle al entorno que queremos que lo cargue, para poder utilizarlo. Para ello emplearemos la función library. Por ejemplo: library(digest) 1.5.6 Ejecutando expresiones desde un fichero de texto Hasta ahora hemos visto cómo podemos ejecutar directamente expresiones tecleándolas una a una en la consola de R. Sin embargo, es posible también indicarle al sistema que ejecute un conjunto de expresiones que previamente hayamos escrito en un fichero de texto, al que se le suele denominar script. Esto resulta de utilidad por ejemplo cuando queremos ejecutar varias veces una secuencia larga de operaciones. Para poder cargar y ejecutar las expresiones desde fichero utilizaremos la función source. Por ejemplo, supongamos que disponemos de un fichero (denominado /Users/user1/cmds.r) que tiene el siguiente contenido: # Esto es un comentario z1&lt;-(2*x)+y print(z1) z2&lt;-(2*y)+x print(z2) Para ejecutar las expresiones contenidas en este fichero, podemos teclear la siguiente secuencia de operaciones en la consola de R: x&lt;-2 y&lt;-3 source(&quot;cmds.r&quot;) # [1] 7 # [1] 8 A la hora de hacer nuestros ficheros con expresiones R, tenemos que tener en cuenta un par de aspectos de interés: Aunque no es obligatorio, se suele utilizar por convenio una extensión en el fichero (usualmente .R o .r) que nos indique con qué tipo de fichero estamos trabajando. Nótese que para poder hacer que nuestros resultados se muestren en consola, hemos utilizado la función print. Cuando trabajamos con la consola en modo interactivo, los resultados se imprimen directamente a la salida, sin necesidad de utilizar print. Pero cuando ejecutamos source por defecto los resultados no se imprimen, así que tenemos que hacerlo explícitamente con la llamada a esta función. "],["consejos-prácticos-sobre-el-uso-de-la-consola-de-r.html", "1.6 Consejos prácticos sobre el uso de la consola de R", " 1.6 Consejos prácticos sobre el uso de la consola de R Dado que a lo largo del curso trabajaremos bastante con la consola de R, este es un buen momento para tratar algunos aspectos que seguramente se os plantearán con el uso de la misma: Como ocurre en los terminales de algunos sistemas operativos, en la consola de R es posible acceder al histórico de comandos tecleados utilizando las flechas superior e inferior del teclado. Una vez hemos terminado la sesión con la consola de R, podemos salir de la misma tecleando la expresión q(). Al hacer esto, el sistema nos dará la posibilidad de guardar en un fichero los datos de la sesión (por ejemplo, las variables definidas). Si aceptamos la sugerencia, al volver a lanzar el entorno de R se cargará el estado de la sesión previa tal como la dejamos al salir y podremos seguir trabajando con ella. En caso contrario, las variables que hayamos definido en la última sesión se perderán. También es posible guardar explícitamente el entorno de trabajo cuando queramos (sin necesidad de que sea al final de la sesión) y en un fichero de nuestra elección. En Windows y Mac OS X esto se podría hacer desde los menús del entorno de R. En particular, dependiendo del sistema tendríamos que utilizar: Archivo &gt; Guardar área de trabajo / Archivo &gt; Cargar área de trabajo Workspace &gt; Save Workspace File / Workspace &gt; Load Workspace File Se puede hacer esto mismo desde la consola de R utilizando la función save.image para guardar los datos y la función load para cargarlos. Por ejemplo: save.image(&#39;ws.RData&#39;) load(&#39;ws.RData&#39;) Téngase en cuenta que al cargar datos desde fichero, puede ocurrir que el nombre de alguna de las variables que estemos cargando colisione con otro nombre que tengamos en la sesión. En ese caso, el valor cargado de fichero reescribiría al que hayamos definido previamente en la sesión. Por ejemplo: y&lt;-3.3 save.image(&quot;/Users/user1/ws&quot;) y # [1] 3.3 y&lt;-(-8) y # [1] -8 load(&quot;/Users/user1/ws&quot;) y # [1] 3.3 En ocasiones, tras haber tecleado una larga secuencia de comandos puede que nos resulte de interés limpiar la consola para dejarla en blanco. Para poder hacer esto, podemos utilizar la secuencias de teclado: Linux, Windows: CTRL + L Mac OS X: Command + Option + L "],["el-lenguaje-r.html", "Capítulo 2 El lenguaje R", " Capítulo 2 El lenguaje R Introducción y objetivos Como indicamos en el tema 1, podemos considerar a R como un entorno software, pero también como un lenguaje de programación. En el tema anterior centramos nuestra atención en el entorno y simplemente presentamos algunas características muy básicas del lenguaje (por ejemplo, cómo definir variables). Así pues, el objetivo a lo largo del tema 2 será avanzar en el conocimiento del lenguaje R. Para cumplir con este objetivo, comenzaremos con una breve introducción al lenguaje, en la que indicaremos algunas de sus características clave para, a continuación, pasar a describir sus componentes esenciales: Tipos de datos y operadores básicos. Estructuras de datos complejas (vectores, tablas, listas, etc.). Estructuras de control (condicionales, bucles). Funciones. Además comenzaremos a ver también algunas funciones de librería de R y otros mecanismos básicos de manipulación de datos (por ejemplo, cómo seleccionar datos en un vector, una tabla, etc.). Así pues, cuando hayas finalizado con los contenidos de este tema: Conocerás los principales tipos, operadores y estructuras de datos de R. Habrás aprendido a utilizar las estructuras de control básicas del lenguaje (condicionales, bucles). Serás capaz de crear tus primeras funciones en lenguaje R. Conocerás algunas técnicas y funciones básicas que permiten manipular datos en R. "],["características-básicas-del-lenguaje-r.html", "2.1 Características básicas del lenguaje R", " 2.1 Características básicas del lenguaje R Se trata de un lenguaje interpretado (al estilo de Python) que se ejecuta en el entorno de R sin necesidad de que lo compilemos previamente (a diferencia de otros lenguajes de programación como C o Java). Presenta un esquema de tipos débil, es decir, no será necesario que indiquemos expresamente el tipo de cada variable que definamos, este tipo se inferirá en base a los valores que asignemos a las variables. Ofrece un soporte multiparadigma. R permite la programación orientada a objetos (y de hecho, todo lo que vamos a manejar: funciones, expresiones, estructuras de datos, etc. puede ser considerado un objeto). Sin embargo, el sistema de objetos de R es confuso, debido a que existen diferentes mecanismos alternativos para implementar la programación orientada a objetos (S3, S4). Es por ello por lo que resulta bastante habitual que se trabaje con R como si fuese un lenguaje procedural (es decir, basado en procedimiento o funciones), dejando la programación orientada a objetos para desarrollos más avanzados (como podría ser implementar nuevas librerías o paquetes para R). Nosotros nos centraremos en la perspectiva de usuarios que están interesados en utilizar R para analizar sus dtos, no en la de desarrolladores de paquetes de R, así que no entraremos en el detalle de los mecanismos de programación orientada a objetos. "],["tipos-de-datos-y-operadores.html", "2.2 Tipos de datos y operadores", " 2.2 Tipos de datos y operadores A lo largo de este apartado presentaremos los tipos básicos de datos de R y los operadores asociados a esos tipos. Describiremos además algunas estructuras de datos complejas que nos ofrece el lenguaje. 2.2.1 Tipos básicos de datos A lo largo del tema anterior hemos trabajado únicamente con datos numéricos en todos nuestros ejemplos, sin embargo, existen múltiples tipos básicos de datos que R puede manejar. En particular, estos son: Numérico: es el que utilizamos en el tema anterior y se puede utilizar para representar valores numéricos, tanto enteros como reales. a&lt;--3 a # [1] -3 b&lt;-2.34e-3 b # [1] 0.00234 Complejo: se utiliza para trabajar con números complejos, con parte real e imaginaria (esta última representada por medio del carácter i). c&lt;-2.3+9i c # [1] 2.3+9i Cadena de caracteres (string): permite representar información textual. Para indicar que queremos trabajar con una cadena de caracteres en R utilizaremos las comillas simples o dobles. s&lt;-&quot;Hola&quot; s # [1] &quot;Hola&quot; t&lt;-&#39;Mundo&#39; t # [1] &quot;Mundo&quot; Hay que indicar que es posible utilizar la barra \\ como delimitador cuando queremos incluir algunos caracteres especiales (por ejemplo, un fin de línea, tabulador, comillas dentro de otras comillas, etc). s&lt;-&quot;Hola \\&quot;Mundo\\&quot;&quot; Puedes obtener más información sobre esto en la ayuda de R (con ?Quotes) Lógico (booleano): es un tipo binario que únicamente admite dos valores, verdadero (TRUE) o falso (FALSE). También se pueden utilizar los alias T y F en lugar de TRUE y FALSE, respectivamente. b&lt;-TRUE b # [1] TRUE c&lt;-F c # [1] FALSE 2.2.2 Operadores R ofrece los siguientes tipos fundamentales de operadores: Operadores aritméticos: son los que utilizamos en el tema 1 a la hora de manipular valores numéricos: +, -, /, *, ^, %%, %/%. Estos operadores se pueden utilizar también con valores de tipo complejo, excepto los dos últimos, que están pensados para operandos de tipo numérico. (2+3i)*(-3-2.5i) # [1] 1.5-14i Operadores lógicos: que nos permiten trabajar con valores de tipo lógico: NOT: !x AND: x &amp; y OR: x | y XOR: xor(x,y) TRUE &amp; (!FALSE) # [1] TRUE Operadores de comparación: como su nombre indica, se utilizan para comparar operandos y devuelven un valor lógico que indica si la expresión es cierta o no. Menor que: x&lt;y Menor o igual: x&lt;=y Mayor que: x&gt;y Mayor o igual: x&gt;=y Igualdad: x==y Diferencia: x!=y Estos operadores se utilizan sobre todo en estructuras de control condicionales y suelen estar combinados por medio de &amp;&amp; (AND) y || (OR). (2&lt;3) &amp;&amp; !(TRUE==FALSE) # [1] TRUE Nótese que no hemos definido operadores específicos para cadenas de caracteres y es que estas se van a manipular en R fundamentalmente a través de funciones. "],["estructura-de-datos.html", "2.3 Estructura de datos", " 2.3 Estructura de datos Además de los tipos de datos básicos que hemos cubierto en este tema, R permite trabajar también con estructuras más complejas, que veremos a lo largo de este apartado. 2.3.1 Vectores Es la estructura más simple proporcionada por R y consiste en una secuencia de elementos de un cierto tipo (numérico, complejo, lógico, etc.). En la práctica existen distintos mecanismos que podemos utilizar a la hora de crear un vector, entre los más utilizados destacamos: La función c que simplemente recibe como entrada la secuencia de elementos que queremos especificar en el vector. v&lt;-c(1,3,5,7) v # [1] 1 3 5 7 v&lt;-c(&quot;a&quot;, &quot;b&quot;, &quot;d&quot;) v # [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; También se puede utilizar esta función para concatenar vectores: c(c(1,2),c(1,5),-7) # [1] 1 2 1 5 -7 El operador «:». Si ejecutamos en R una expresión de la forma x:y (con x e y numéricos) veremos que se crea una secuencia desde x hasta y, donde cada uno de los elementos de la secuencia está separado por una unidad. v&lt;-2:7 v # [1] 2 3 4 5 6 7 3.2:7.8 # [1] 3.2 4.2 5.2 6.2 7.2 La función seq permite crear una secuencia numérica desde un valor inicial a uno final, indicando también el paso que separa dos elementos consecutivos. v&lt;-seq(2.0, 3.2, 0.1) v # [1] 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9 3.0 3.1 3.2 La función rep permite crear secuencias con elementos repetidos, indicando primero el elemento o elementos a repetir y después el número de repeticiones. v&lt;-rep(c(1,2),4) v # [1] 1 2 1 2 1 2 1 2 La función append se puede utilizar para añadir elementos a un vector. v&lt;-c() v&lt;-append(v, 1:3) v&lt;-append(v, 7) v # [1] 1 2 3 7 Es posible utilizar los operadores con vectores: v&lt;-c(T, F, F, T, T) v # [1] TRUE FALSE FALSE TRUE TRUE v&amp;F # [1] FALSE FALSE FALSE FALSE FALSE v&lt;-seq(3,7,0.5) m&lt;-(v&lt;5) m # [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE 2*v+1 # [1] 7 8 9 10 11 12 13 14 15 Nótese que también es posible realizar operaciones con dos o más vectores (componente a componente): v1&lt;-seq(-1,-5) v2&lt;-seq(2,6) v1+v2 # [1] 1 1 1 1 1 En este último caso, tenemos que tener cuidado si los vectores con los que queremos operar no tienen la misma longitud (podemos obtener esta longitud con la función length). En ese caso los elementos del vector más pequeño se reutilizan hasta completar el tamaño necesario: v1&lt;-c(1,2) v2&lt;-rep(-1,6) length(v1) # [1] 2 length(v2) # [1] 6 v2*v1 # [1] -1 -2 -1 -2 -1 -2 Una vez tenemos creado un vector, también nos puede interesar seleccionar una parte del mismo para trabajar solo con ella. Para hacer esto, utilizaremos los corchetes [] y pasaremos en el interior de esos corchetes un vector que permitirá seleccionar los elementos. Tenemos varias alternativas para hacer esta selección: Utilizar un vector de números (enteros) positivos indicando las posiciones de los elementos que queremos seleccionar. Utilizar un vector de números (enteros) negativos indicando las posiciones de los elementos que queremos excluir. Utilizar un vector de componentes de tipo lógico, que deberán tener el valor TRUE en las posiciones que queremos seleccionar y FALSE en las que no. Podemos ver estos tres mecanismos en acción en el siguiente ejemplo: v&lt;-seq(-5,5) v[1:7] # [1] -5 -4 -3 -2 -1 0 1 v[c(-1,-4)] # [1] -4 -3 -1 0 1 2 3 4 5 v[v&lt;2] # [1] -5 -4 -3 -2 -1 0 1 Es posible utilizar los mecanismos de selección arriba indicados para modificar una parte de un vector, como por ejemplo: v[v&lt;0]&lt;-0 v # [1] 0 0 0 0 0 0 1 2 3 4 5 También es posible seleccionar un elemento en una posición concreta (la primera posición es la 1) por medio del doble corchete: v&lt;-seq(-5,5) v[[2]] # [1] -4 2.3.2 Matrices y arrays Extienden el concepto de vector a dos dimensiones (matrices) o más (arrays). Son, por tanto, estructuras en las que los valores de las celdas pertenecen a un tipo concreto (numérico, complejo, lógico). Para crear estas estructuras de datos, tenemos dos funciones específicas: La función matrix se utiliza para crear matrices. Sus tres argumentos principales son: (1) un vector conteniendo los datos de las celdas de la matriz, (2) el número de filas de la matriz y (3) el número de columnas de la matriz. datos&lt;-seq(1,12) m&lt;-matrix(datos, 3, 4) m # [,1] [,2] [,3] [,4] # [1,] 1 4 7 10 # [2,] 2 5 8 11 # [3,] 3 6 9 12 La función array es similar a la anterior. Recibe también como primer parámetro los datos para construir el array pero, en lugar de especificar directamente el número de filas y columnas, el segundo parámetro es un vector que indica las dimensiones. datos&lt;-seq(1,12) m&lt;-array(datos, c(3,2,2)) m # , , 1 # [,1] [,2] # [1,] 1 4 # [2,] 2 5 # [3,] 3 6 # , , 2 # [,1] [,2] # [1,] 7 10 # [2,] 8 11 # [3,] 9 12 Al igual que ocurría con los vectores, también podemos seleccionar una parte de una matriz o array para operar con ella. De hecho, el mecanismo a utilizar es el mismo, basado en los corchetes y en vectores conteniendo índices o valores lógicos. La diferencia es que ahora tenemos varias dimensiones, así que dentro de los corchetes puede haber varios vectores. Por ejemplo, operando sobre el array m anterior: m[1:2,,2] # [,1] [,2] # [1,] 7 10 # [2,] 8 11 Se puede ver que dentro de los corchetes hay tres elementos, uno por dimensión del array. Obsérvese también que el segundo elemento está vacío, lo cual quiere decir que se cogen todos los elementos de esa dimensión. Las matrices y arrays son compatibles también con el uso de los operadores que vimos en secciones anteriores (siempre que el tipo de las celdas permita el uso de esos operadores, por ejemplo, no será posible sumar matrices cuyas celdas sean cadenas de caracteres): m1&lt;-matrix(seq(1,12), 3, 4) m2&lt;-matrix(rep(c(1,0,-1), 4), 3, 4) m1+m2 # [,1] [,2] [,3] [,4] # [1,] 2 5 8 11 # [2,] 2 5 8 11 # [3,] 2 5 8 11 Como se puede ver, al igual que ocurría con los vectores, estos operadores actúan elemento a elemento. Por tanto, si queremos calcular el producto matricial necesitaremos un operador específico: %*% m1 %*% t(m2) # [,1] [,2] [,3] # [1,] 22 0 -22 # [2,] 26 0 -26 # [3,] 30 0 -30 Se puede ver en este ejemplo que se ha utilizado la función t para calcular la traspuesta de la matriz. Otras funciones que se suelen emplear habitualmente con matrices y/o arrays son: La función dim permite obtener las dimensiones de la matriz o array. La función solve se utiliza para invertir una matriz (o resolver sistemas de ecuaciones asociados a esa matriz). La función diag sirve para obtener la diagonal principal de una matriz o para crear matrices diagonales (como la matriz identidad). La función det permite calcular el determinante de una matriz cuadrada. La función apply permite aplicar una determinada función a los elementos de una matriz o array. Las funciones lower.tri y upper.tri nos servirán de ayuda a la hora de obtener una matriz triangular inferior o superior a partir de una dada. Podemos ver a continuación ejemplos de uso de estas funciones: A&lt;-matrix(-4:4,3,3) + diag(3) A # [,1] [,2] [,3] # [1,] -3 -1 2 # [2,] -3 1 3 # [3,] -2 1 5 diag(A) # [1] -3 1 5 dim(A) # [1] 3 3 det(A) # [1] -17 b&lt;-c(1,-1,1) solve(A,b) # [1] 0.5882353 -1.3529412 0.7058824 apply(A, 1, sum) # Aplicamos la función sum para sumar las filas # [1] -2 1 4 apply(A, 2, sum) # Aplicamos la función sum para sumar las columnas # [1] -8 1 10 solve(A) %*% A # [,1] [,2] [,3] # [1,] 1.000000e+00 5.551115e-17 -2.220446e-16 # [2,] 2.775558e-16 1.000000e+00 0.000000e+00 # [3,] 0.000000e+00 5.551115e-17 1.000000e+00 lower.tri(A) # [,1] [,2] [,3] # [1,] FALSE FALSE FALSE # [2,] TRUE FALSE FALSE # [3,] TRUE TRUE FALSE A[lower.tri(A)]&lt;-0 A # [,1] [,2] [,3] # [1,] -3 -1 2 # [2,] 0 1 3 # [3,] 0 0 5 Puedes encontrar más información sobre estas funciones en la ayuda de R 2.3.3 Listas Al igual que los vectores, representan secuencias de elementos, pero a diferencia de estos, en las listas de R se pueden combinar elementos de distintos tipos. Para construirlas, utilizaremos la función list que recibirá como entrada los elementos de la lista: l&lt;-list(3.2, &quot;Hola&quot;, TRUE, 2+4.2i) l [[1]] # [1] 3.2 [[2]] # [1] &quot;Hola&quot; [[3]] # [1] TRUE [[4]] # [1] 2+4.2i Los elementos de una lista están numerados y, por tanto, es posible acceder a una posición concreta o seleccionar una parte de la lista utilizando los mismos mecanismos que vimos con vectores [] y corchete doble. También es posible asignar nombres a los componentes y acceder en base a esos nombres: alumno&lt;-list(nota=7.2, nombre=&quot;N. Fernandez&quot;, aprobado=TRUE) alumno$nota # [1] 7.2 alumno[[2]] # [1] &quot;N. Fernandez&quot; A la hora de acceder a los campos por nombre, tenemos que tener en cuenta que podemos abreviar el nombre, usando un prefijo más corto, siempre que el resultado sea no ambiguo (es decir, que no haya dos o más nombres con el mismo prefijo): alumno&lt;-list(nota=7.2, nombre=&quot;N. Fernandez&quot;, aprobado=TRUE) alumno$no NULL alumno$nom # [1] &quot;N. Fernandez&quot; alumno$ap # [1] TRUE Nótese que en el caso de acceder al nombre «no» el resultado es NULL (valor nulo), puesto que se trata de un prefijo ambiguo (válido para referirse tanto a «nota» como a «nombre»). Normalmente las listas se utilizan para representar estructuras de datos, no utilizaremos los operadores directamente sobre listas (por ejemplo, sumando dos listas), aunque sí podemos operar con sus elementos: alumno1&lt;-list(nota=7.2, nombre=&quot;N. Fernandez&quot;, aprobado=TRUE) alumno2&lt;-list(nota=8.3, nombre=&quot;M. Salgueiro&quot;, aprobado=TRUE) alumno1+alumno2 Error en alumno1 + alumno2 : argumento no-numérico para operador binario (alumno1$nota + alumno2$nota)/2 # [1] 7.75 También podemos utilizar la función lapply para aplicar una función a los elementos de una lista: l&lt;-list(a=seq(1,4), b=rep(1,4)) # Una lista con dos vectores lapply(l, sum) # Para cada elemento de la lista (vector) # sumamos sus componentes $a # [1] 10 $b # [1] 4 2.3.4 Factores (factors) Un factor es un vector que se utiliza para especificar los niveles de los que consta una clasificación discreta (variable categórica). Su uso es similar al de un tipo enumerado en otros lenguajes de programación. Para crear un factor, utilizaremos la función factor, que recibirá como entrada un vector con los distintos valores de los niveles: dias&lt;-factor(levels = c(&quot;L&quot;, &quot;M&quot;, &quot;X&quot;, &quot;J&quot;, &quot;V&quot;)) Utilizando la función levels, podemos obtener un listado de los distintos niveles que tiene asignado un factor: levels(dias) # [1] &quot;L&quot; &quot;M&quot; &quot;X&quot; &quot;J&quot; &quot;V&quot; También podemos crear un factor a partir de datos numéricos empleando la función cut. Esta función se utiliza a la hora de convertir una variable continua en una categórica, mediante la división de la variable continua en intervalos, cuyos límites se indican con el parámetro breaks: notas&lt;-c(1.7,6.4,5.3,9.8,3.5,7.8) cut(notas, breaks=c(0,5,7.5,9,10)) # [1] (0,5] (5,7.5] (5,7.5] (9,10] (0,5] (7.5,9] Levels: (0,5] (5,7.5] (7.5,9] (9,10] Para cada intervalo es posible especificar una etiqueta por medio del parámetro labels: cut(notas, breaks=c(0,5,7.5,9,10), labels=c(&quot;Sus&quot;,&quot;Apr&quot;,&quot;Not&quot;,&quot;Sob&quot;)) # [1] Sus Apr Apr Sob Sus Not Levels: Sus Apr Not Sob Los factores se suelen utilizar en combinación con la función tapply, que usualmente toma como entradas un vector con datos, un factor que permite establecer el grupo al que pertenece cada uno de los datos, y una función. Esta función se aplica a los elementos del vector de datos según el grupo al que pertenecen. Veamos un ejemplo, en el que queremos calcular la media (función mean) de unas muestras que representan alturas de individuos pertenecientes a dos grupos distintos: alturas&lt;-c(1.75, 1.68, 1.72, 2.03, 1.73, 1.69, 1.83, 1.92) grupos&lt;-factor(rep(c(&quot;Grupo1&quot;, &quot;Grupo2&quot;), 4)) grupos # [1] Grupo1 Grupo2 Grupo1 Grupo2 Grupo1 Grupo2 Grupo1 Grupo2 Levels: Grupo1 Grupo2 tapply(alturas, grupos, mean) Grupo1 Grupo2 1.7575 1.8300 Nótese que hemos llamado a la función factor utilizando directamente un vector de datos, en lugar de especificar los niveles con el parámetro levels. En este caso, el sistema extrae automáticamente los niveles quedándose con los valores distintos del vector de entrada (en este caso, «Grupo1» y «Grupo2»). 2.3.5 Tablas (data frames) Al igual que las listas permitían extender el concepto de vector y trabajar con distintos tipos de elementos, las tablas (data frames en nomenclatura de R) permiten extender el concepto de matriz y trabajar con estructuras tabulares que tienen elementos de distintos tipos de datos. Se pueden construir data frames a partir de vectores, factores, matrices, listas u otros data frames. Por ejemplo, supongamos que tenemos un vector con datos de alturas y un factor con los grupos a los que pertenecen cada uno de los datos (como vimos en el ejemplo del apartado anterior). Es sencillo construir un data frame a partir de estos elementos, utilizando una llamada a la función data.frame. alturas&lt;-c(1.75, 1.68, 1.72, 2.03, 1.73, 1.69, 1.83, 1.92) grupos&lt;-factor(rep(c(&quot;Grupo1&quot;, &quot;Grupo2&quot;), 4)) tabla&lt;-data.frame(Alturas=alturas, Grupos=grupos) tabla Alturas Grupos 1 1.75 Grupo1 2 1.68 Grupo2 3 1.72 Grupo1 4 2.03 Grupo2 5 1.73 Grupo1 6 1.69 Grupo2 7 1.83 Grupo1 8 1.92 Grupo2 Como se puede ver se ha creado una estructura tabular de dos columnas. A cada una de estas columnas se le ha asignado el nombre que indicamos en la llamada para crear la tabla («Alturas» y «Grupos»). También se le ha asignado automáticamente un nombre a cada una de las filas (en este caso con valores numéricos por defecto). Podemos cambiar las etiquetas de la siguiente forma: colnames(tabla)&lt;-c(&quot;Alt&quot;,&quot;Grp&quot;) rownames(tabla)&lt;-c(&quot;U1&quot;,&quot;U2&quot;,&quot;U3&quot;,&quot;U4&quot;,&quot;U5&quot;,&quot;U6&quot;,&quot;U7&quot;,&quot;U8&quot;) tabla Alt Grp U1 1.75 Grupo1 U2 1.68 Grupo2 U3 1.72 Grupo1 U4 2.03 Grupo2 U5 1.73 Grupo1 U6 1.69 Grupo2 U7 1.83 Grupo1 U8 1.92 Grupo2 Podemos utilizar esos nombres para acceder a los datos de la tabla tabla$Alt # [1] 1.75 1.68 1.72 2.03 1.73 1.69 1.83 1.92 tabla[&quot;U5&quot;,] # Alt Grp # U5 1.73 Grupo1  o para añadir nuevas entradas tabla$Nueva&lt;-seq(1,8) # Nueva columna tabla[&quot;U9&quot;,]&lt;-list(Alt=1.59, Grp=&quot;Grupo2&quot;, Nueva=9) # Nueva fila tabla # Alt Grp Nueva # U1 1.75 Grupo1 1 # U2 1.68 Grupo2 2 # U3 1.72 Grupo1 3 # U4 2.03 Grupo2 4 # U5 1.73 Grupo1 5 # U6 1.69 Grupo2 6 # U7 1.83 Grupo1 7 # U8 1.92 Grupo2 8 # U9 1.59 Grupo2 9 También es posible acceder a los datos de una tabla utilizando índices, al igual que ocurría en las matrices: tabla[1,] # Alt Grp # U1 1.75 Grupo1 tabla[,1] # [1] 1.75 1.68 1.72 2.03 1.73 1.69 1.83 1.92 tabla[3,1] # [1] 1.72 R proporciona múltiples funciones que podemos utilizar para manipular data frames. Entre las más empleadas se encuentran La función dim para obtener las dimensiones de la tabla. Las funciones nrow y ncol permiten obtener, respectivamente, el número de filas y columnas del data frame. La función names permite obtener los nombres de las distintas columnas del data frame, mientras que dimnames que permite obtener los nombres de filas y columnas. La función str permite visualizar información sobre la estructura de la tabla. Podemos ver a continuación ejemplos de uso de estas funciones: names(tabla) # [1] &quot;Alt&quot; &quot;Grp&quot; &quot;Nueva&quot; dimnames(tabla) [[1]] # [1] &quot;U1&quot; &quot;U2&quot; &quot;U3&quot; &quot;U4&quot; &quot;U5&quot; &quot;U6&quot; &quot;U7&quot; &quot;U8&quot; &quot;U9&quot; [[2]] # [1] &quot;Alt&quot; &quot;Grp&quot; &quot;Nueva&quot; dim(tabla) # [1] 9 3 nrow(tabla) # [1] 9 str(tabla) # &#39;data.frame&#39;: 9 obs. of 3 variables: # $ Alt : num 1.75 1.68 1.72 2.03 1.73 1.69 1.83 1.92 1.59 # $ Grp : Factor w/ 2 levels &quot;Grupo1&quot;,&quot;Grupo2&quot;: 1 2 1 2 1 2 1 2 2 # $ Nueva: num 1 2 3 4 5 6 7 8 9 Al igual que ocurría con las listas, no utilizaremos los operadores directamente sobre data frames (por ejemplo, sumando dos tablas), aunque sí podemos operar con sus elementos (por ejemplo, sumar columnas numéricas de data frames). "],["estructuras-de-control.html", "2.4 Estructuras de control", " 2.4 Estructuras de control Al igual que la mayoría de los lenguajes de programación, R ofrece una serie de estructuras que permiten controlar el flujo de ejecución de nuestro código. Básicamente, existen dos familias de estructuras, que veremos en los siguientes apartados. en la ayuda de R (con ?Control). 2.4.1 Condicionales Se utilizan para especificar que cierto fragmento de código solo se debe ejecutar cuando se cumpla una (o varias) condiciones. Existen varias alternativas dentro de este tipo de estructura de control, las más importantes son: if-else: if (a &lt; b) { max&lt;-b } else { max&lt;-a } ifelse: se trata de una función que recibe tres argumentos, una expresión a evaluar (de tipo lógico), el resultado cuando la expresión sea cierta y el resultado cuando la expresión sea falsa. Se utiliza mucho por ejemplo con vectores, para evaluar una condición en todos los elementos del vector. x&lt;-c(1,-2,4,-3.2,0,-9) y&lt;-ifelse(x&lt;0, -x, x) y # [1] 1.0 2.0 4.0 3.2 0.0 9.0 2.4.2 Bucles Permiten repetir cierto código un determinado número de veces. Básicamente existen tres mecanismos para implementar bucles en R: for: recorre los elementos de una secuencia (por ejemplo un vector) y para cada uno de ellos repite el código que se proporciona. total&lt;-0 for (i in c(2,3,5,8)) { total&lt;-total + i } while: se ejecuta el código del bucle mientras se cumpla la condición. y&lt;-0; suma&lt;-0 while (y &lt; 5) { suma &lt;- suma+y y &lt;- y+1 } repeat: se repite cierto código hasta que se ejecuta un break, que indica que saldremos del bucle. y&lt;-0; suma&lt;-0 repeat { suma &lt;- suma+y y &lt;- y+1 if (y == 5) break } Una cosa que debemos tener en cuenta es que, cuando sea posible llevar a cabo una misma operación por medio de una función predefinida operando sobre un vector o, alternativamente, por medio de un bucle, suele ser mucho más eficiente utilizar la función y el vector que crear nosotros un bucle. Así pues, en el ejemplo que pusimos para el caso del for, sería más eficiente haber hecho una llamada a la función sum para sumar los elementos del vector que utilizar el bucle arriba indicado. También las funciones apply/lapply/tapply se pueden utilizar con frecuencia para reemplazar bucles (puesto que permiten iterar sobre estructuras complejas de datos). "],["funciones.html", "2.5 Funciones", " 2.5 Funciones Tanto en el tema previo como a lo largo de los apartados anteriores de este tema, hemos visto que existen multitud de funciones que nos permiten manipular datos en R. Por supuesto, también es posible crear nuestras propias funciones, para lo que utilizaremos la palabra reservada function. Veamos un ejemplo de una función sencilla: sumprod&lt;-function(x, y) { return ((x+y)/(x*y)) } Donde se puede ver que hemos definido una función de nombre «sumprod» que tiene dos parámetros de entrada («x» e «y») y devuelve un resultado (con return). Podemos declarar directamente la función en el terminal de R, o en un script, tal como vimos en el tema anterior. Una vez declarada, se puede utilizar directamente por su nombre: sumprod(2,3) # [1] 0.8333333 También es posible definir nuevos operadores binarios, asignando el símbolo del operador a utilizar el lugar del nombre de la función &quot;%@%&quot;&lt;-function(x, y) { return ((x+y)/(x*y)) } Y luego simplemente utilizamos directamente el nuevo operador para llamar a la función: 2%@%3 # [1] 0.8333333 Aunque en los ejemplos anteriores hemos utilizado la posición de los argumentos para que el sistema sepa qué es «x» y qué «y», es posible pasar los parámetros por nombre explícitamente: sumprod(y=3, x=2) # [1] 0.8333333 También es posible especificar valores por defecto en los parámetros de la función (de forma que si no se proporcionan en el momento de hacer la llamada, se toman de la declaración), por ejemplo: sumprod&lt;-function(x, y=1) { return ((x+y)/(x*y)) } sumprod(3) # [1] 1.333333 Incluso es posible que esos valores por defecto no sean constantes, sino que se obtengan a partir de otros parámetros: sumprod&lt;-function(x, y=length(x)) { return ((x+y)/(x*y)) } v&lt;-seq(1,3) sumprod(v) # [1] 1.3333333 0.8333333 0.6666667 Podemos utilizar la función missing para comprobar si un determinado parámetro ha sido proporcionado o no a la hora de llamar a nuestra función: f&lt;-function(x=1, y) { if (missing(y)) { y&lt;-2 } return(x+y) } f(2) # [1] 4 f(2,3) # [1] 5 R también nos permite indicar que pueden existir una serie de parámetros adicionales que no son conocidos en el momento de declarar la función. Esto es útil, por ejemplo, cuando desde una función queremos llamar a otra y necesitamos los argumentos de esa segunda función, pero no sabemos cuáles van a ser (pensad en el caso de la funciones apply/lapply/tapply, que vimos en este tema). Para hacer esto, incluiremos en el listado de parámetros de nuestra función puntos suspensivos (denominados formalmente ellipsis), y accederemos a los valores que ahí se proporcionan como una lista. Por ejemplo: f&lt;-function(x, y=2, ...) { args&lt;-list(...) # Obtenemos la lista de argumentos for (arg in args) { # Recorremos la lista print(arg) } } "],["análisis-de-datos-con-r-i.html", "Capítulo 3 Análisis de datos con R (I)", " Capítulo 3 Análisis de datos con R (I) Introducción y objetivos Tras haber descrito en el tema anterior los principales elementos de los que consta el lenguaje R, pasaremos a analizar ahora con más detalle los mecanismos y funciones que el lenguaje proporciona para la manipulación y análisis de datos. Dado que es imposible hacer una descripción exhaustiva de todas las funcionalidades de análisis que R pone a nuestro alcance, nos centraremos en presentar muy brevemente y de una manera práctica (casi como en un tutorial) los mecanismos que podemos utilizar para realizar algunas tareas de análisis de uso común. Para conseguir este objetivo, seguiremos las siguientes etapas: Comenzaremos presentando algunos mecanismos y funciones de uso común a la hora de manipular datos en R. A continuación, veremos cómo utilizar R para realizar tareas básicas de análisis y caracterización estadística de datos. Finalizaremos con una introducción al uso de R como herramienta para la minería de datos. Cuando hayas finalizado con los contenidos de este tema Habrás aprendido algunas técnicas de manipulación de datos de uso común en R (como por ejemplo, cómo ordenar datos, convertir entre distintos tipos de datos, manejar cadenas de caracteres o importar/exportar datos a fichero). Sabrás cómo obtener las estadísticas básicas (media, mediana, desviación típica, etc.) de unos datos. Podrás caracterizar estadísticamente unos datos mediante el uso de técnicas gráficas (como el histograma o el diagrama de caja). Podrás llevar a cabo test estadísticos sencillos (como el test t). Sabrás cómo podemos usar R para calcular la recta de regresión que mejor representa a unos datos dados. Habrás aprendido a utilizar R como herramienta para realizar tareas básicas de minería de datos (clasificación, agrupamiento de datos, etc.). "],["manipulación-de-datos.html", "3.1 Manipulación de datos", " 3.1 Manipulación de datos En los siguientes apartados veremos cómo resolver con R algunas tareas de manipulación de datos que van a aparecer frecuentemente al utilizar la herramienta. 3.1.1 Tratamiento de valores desconocidos En ocasiones es posible que no sepamos cuál es el valor concreto de un determinado elemento de una estructura de datos (vector, lista, etc.). Para hacer frente a esta situación, R nos ofrece la posibilidad de utilizar un valor reservado, denominado NA (del inglés Not Available). Así por ejemplo: v&lt;-c(2.3, -1.2, 2.4, NA, 0.7) v # [1] 2.3 -1.2 2.4 NA 0.7 Nótese que NA se representa sin comillas (no es una cadena de caracteres). Al realizar cualquier operación que involucre a un valor NA, el resultado será necesariamente un NA: v&lt;-c(2.3, -1.2, 2.4, NA, 0.7) 2*v # [1] 4.6 -2.4 4.8 NA 1.4 A través de la función is.na podemos comprobar si un determinado valor es o no desconocido: v&lt;-c(2.3, -1.2, 2.4, NA, 0.7) is.na(v) # [1] FALSE FALSE FALSE TRUE FALSE También podemos eliminar los valores desconocidos de una estructura de datos (vector, data frame) utilizando la función na.omit: r&lt;-c(na.omit(v)) r # [1] 2.3 -1.2 2.4 0.7 3.1.2 Conversión de tipos Como vimos en el tema anterior, existe una amplia variedad de tipos y estructuras de datos que podemos utilizar para manejar información en R. En ocasiones nos interesará poder convertir información de uno a otro tipo (por ejemplo, un número a una cadena de caracteres). Para facilitar esta tarea, existe toda una familia de funciones en R (cuyo nombre tiene la forma as.tipo, como por ejemplo, as.numeric) que podemos utilizar. Podemos ver a continuación algunos ejemplos de uso de estas funciones: as.numeric(&#39;12.3&#39;) # [1] 12.3 # Definir el data frame tabla Nombre &lt;- c(&quot;Mario&quot;,&quot;Anton&quot;,&quot;Ana&quot;) Edad &lt;- c(36, 23, 36) Peso &lt;- c(78.5, 83.9, 65.4) Sexo &lt;- c(&quot;M&quot;,&quot;M&quot;,&quot;F&quot;) tabla &lt;- data.frame(Nombre,Edad,Peso,Sexo) tabla # Un data frame previamente definido # Nombre Edad Peso Sexo # 1 Mario 36 78.5 M # 2 Anton 23 83.9 M # 3 Ana 36 65.4 F as.matrix(tabla) # Nombre Edad Peso Sexo # [1,] &quot;Mario&quot; &quot;36&quot; &quot;78.5&quot; &quot;M&quot; # [2,] &quot;Antón&quot; &quot;23&quot; &quot;83.9&quot; &quot;M&quot; # [3,] &quot;Ana&quot; &quot;36&quot; &quot;65.4&quot; &quot;F&quot; Se puede ver en este último ejemplo que, dado que las matrices tienen que tener todos sus valores del mismo tipo, se convierten automáticamente todas las entradas del data frame a un tipo común (en este caso, cadena de caracteres). Otra función que puede ser de utilidad a la hora de convertir tipos es la función unlist, que devuelve un vector conteniendo los elementos de una lista. lista&lt;-list(2, 1+3i, &quot;Hola&quot;) unlist(lista) # [1] &quot;2&quot; &quot;1+3i&quot; &quot;Hola&quot; Donde de nuevo se puede ver que se ha llevado a cabo una conversión automática de los valores de la lista en cadenas de caracteres, puesto que los elementos de un vector deben ser todos del mismo tipo. 3.1.3 Ordenación de datos R nos ofrece funciones de librería para poder llevar a cabo la ordenación de los datos incluidos en una estructura. Ahora bien, la función a utilizar dependerá de la estructura concreta de datos con la que vayamos a trabajar: La función sort se emplea cuando queremos ordenar vectores. Por defecto la ordenación es ascendente, aunque se puede configurar mediante el parámetro decreasing: v&lt;-c(2,1,5,-2,3,0) sort(v) # [1] -2 0 1 2 3 5 sort(v, decreasing=T) # [1] 5 3 2 1 0 -2 La función order se utiliza fundamentalmente con data frames y nos va a permitir ordenar la tabla en base a una columna o columnas de la misma. Podemos utilizar también el parámetro decreasing para indicar si el orden es o no decreciente. tabla # Un data frame previamente creado # Nombre Edad Peso Sexo # 1 Mario 36 78.5 M # 2 Antón 23 83.9 M # 3 Ana 36 65.4 F tabla[order(tabla$Edad,tabla$Peso),] # Nombre Edad Peso Sexo # 2 Antón 23 83.9 M # 3 Ana 36 65.4 F # 1 Mario 36 78.5 M 3.1.4 Búsqueda de datos En el tema anterior vimos cómo podíamos seleccionar ciertos datos de una estructura de datos concreta (utilizando los operadores de corchete [] y corchete doble. La función which, de R está relacionada con estos operadores, ya que nos permite buscar los elemento de una determinada estructura de datos que cumplan cierta condición, devolviéndonos la posición (o posiciones) de los elementos que cumplen la condición: v&lt;-c(2,1,5,-2,3,0) v[v&lt;0] # Selección # [1] -2 which(v&lt;0) # Buscar el índice dónde se cumple la condición # [1] 4 tabla # Un data frame previamente creado # Nombre Edad Peso Sexo # 1 Mario 36 78.5 M # 2 Antón 23 83.9 M # 3 Ana 36 65.4 F tabla[(tabla$Peso&gt;70)&amp;(tabla$Edad&lt;30),] # Selección # Nombre Edad Peso Sexo # 2 Antón 23 83.9 M which((tabla$Peso&gt;70)&amp;(tabla$Edad&lt;30)) # Búsqueda de índices # [1] 2 3.1.5 Manipulación de cadenas de caracteres Como indicamos en el tema anterior, la manipulación de cadenas de caracteres suele llevarse a cabo por medio de funciones, no operadores (por ejemplo, no podemos sumar cadenas de caracteres). Algunas de las funciones de manipulación de cadenas de caracteres más utilizadas son: La función substr que permite extraer (o reemplazar) una subcadena dentro de una cadena. La función grep que permite la búsqueda de patrones en una cadena, bien indicados mediante una expresión regular o bien patrones fijos (para lo que usaremos el parámetro fixed con valor TRUE en la llamada a la función). La función strsplit permite trocear una cadena de caracteres mediante un delimitador dado. La función paste permite unir cadenas utilizando un separador dado entre ellas, que se establece mediante el parámetro sep. Cuando los argumentos contienen múltiples elementos (por ejemplo, son vectores) se puede hacer que se concatenen todos ellos con un separador dado en el parámetro collapse. Podemos ver a continuación algunos ejemplos de uso de estas funciones: cad&lt;-&quot;Hola Mundo&quot; substr(cad, 2, 4) # [1] &quot;ola&quot; substr(cad, 2, 4)&lt;-&quot;OLA&quot; cad # [1] &quot;HOLA Mundo&quot; grep(&quot;.ab.&quot;, c(&quot;Ejemplo&quot;,&quot;Cabeza&quot;,&quot;Abecedario&quot;,&quot;C.ab.o&quot;)) # [1] 2 4 grep(&quot;.ab.&quot;, c(&quot;Ejemplo&quot;,&quot;Cabeza&quot;,&quot;Abecedario&quot;,&quot;C.ab.o&quot;), fixed=T) # [1] 4 strsplit(&quot;En un lugar de la Mancha&quot;, &quot; &quot;) [[1]] # [1] &quot;En&quot; &quot;un&quot; &quot;lugar&quot; &quot;de&quot; &quot;la&quot; &quot;Mancha&quot; paste(&quot;Hola&quot;, &quot;Mundo&quot;, sep=&quot;_&quot;) # [1] &quot;Hola_Mundo&quot; paste(seq(1,5), &quot;a&quot;, sep=&quot;+&quot;) # [1] &quot;1+a&quot; &quot;2+a&quot; &quot;3+a&quot; &quot;4+a&quot; &quot;5+a&quot; paste(seq(1,5), seq(5,1), sep=&quot;*&quot;, collapse=&quot;-&quot;) # [1] &quot;1*5-2*4-3*3-4*2-5*1&quot; 3.1.6 Importar/exportar datos desde/a fichero Aunque en los ejemplos que hemos visto hasta ahora hemos introducido la información a analizar directamente en la consola de R, el caso más habitual es que esta se encuentre en un fichero, y que, por tanto, tengamos que importar los datos antes de proceder a su análisis. Aunque existen paquetes de R que nos permiten interactuar con formatos diversos (por ejemplo, XML, Excel, formatos de otro software estadístico, como SPSS o SAS, etc.) el caso más habitual (y el que trataremos en esta sección) es el de leer los datos desde un fichero de texto. Para poder importar datos desde fichero al entorno de R usaremos fundamentalmente una de las dos siguientes opciones: La función read.table que nos permite leer datos en formato tabular (y que se utiliza para leer data frames). Los principales argumentos de esta función son: file: representa el fichero del que queremos leer los datos. header: un valor lógico que nos indica si la primera línea debe ser tratada como la cabecera (nombre de las columnas de datos). sep: por defecto se usan como delimitadores los espacios en blanco (espacios, tabuladores, fines de línea). Si ese no es nuestro caso, se puede indicar expresamente el delimitador que separa los valores con este parámetro. fileEncoding: indica cómo se representa la información almacenada en el fichero (con qué estándar de codificación de caracteres, como UTF-8, ASCII, etc). Por ejemplo, si tenemos un fichero cuya ruta es /path/to/datos.dat y cuyo contenido (en codificación UTF-8) es: Nombre,Edad,Peso,Sexo Mario,36,78.5,M Antón,23,83.9,M Ana,36,65.4,F Podemos leer esos datos en un data frame de R ejecutando en la consola: tabla&lt;-read.table(&quot;/path/to/datos.dat&quot;, sep=&quot;,&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) Si no conocemos la ruta del fichero donde se encuentran los datos puede ser de utilidad la función file.choose que abre una ventana del explorador de ficheros para permitir elegir interactivamente dicha ruta. tabla&lt;-read.table(file.choose(), sep=&quot;,&quot;, header=TRUE, fileEncoding=&quot;UTF-8&quot;) La función scan que se suele utilizar cuando lo que queremos leer son vectores. Además de los argumentos file, sep y fileEncoding, que ya hemos visto en read.table, otros argumentos relevantes son: what: indica qué tipo de datos vamos a leer del fichero (logical, numeric, complex, etc). n: número máximo de elementos que queremos leer del fichero (si hay más, se descartan). Por ejemplo, si tenemos un fichero de texto /path/to/lista.dat con el siguiente contenido: 1,2,3,4,5,6,7,8,9,10 Podemos leer sus 8 primeros datos como un vector numérico de R haciendo: vec&lt;-scan(&quot;/path/to/lista.dat&quot;, what=numeric(), n=8, sep=&quot;,&quot;) También es posible exportar la información a un fichero de texto. Dos de las funciones más utilizadas con este fin son: La función write.table que permite volcar a fichero una tabla (data frame). Si consultamos la ayuda de R, veremos que sus principales argumentos son: x: el data frame que queremos volcar a fichero. file: el fichero de destino. sep: separador de los distintos datos. fileEncoding: codificación de caracteres a utilizar. La función write que se suele utilizar para exportar vectores y que tiene tres argumentos principales: x: datos a exportar. file: fichero de destino. sep: separador de los distintos datos. Por ejemplo, podemos volcar a fichero el data frame tabla y el vector vec leídos en los ejemplos anteriores haciendo: write.table(tabla, file=&quot;/path/to/tabla.data&quot;) write(vec, file=&quot;/path/to/vector.data&quot;) "],["estadística-básica-con-r.html", "3.2 Estadística básica con R", " 3.2 Estadística básica con R En los siguientes apartados veremos cómo utilizar R para realizar tareas estadísticas básicas. En particular, trataremos aspectos como: Manejo de distribuciones estadísticas de uso frecuente (como la distribución normal). Caracterización estadística de datos (estadística descriptiva). Realización de contrastes de hipótesis mediante test básicos (estadística inferencial). 3.2.1 Distribuciones estadísticas Las distribuciones más habitualmente utilizadas a la hora de modelar estadísticamente unos datos o para llevar a cabo tests están implementadas en R. Entre ellas se incluyen (con su nombre en R entre paréntesis) las distribuciones binomial (binom), Chi-cuadrado (chisq), exponencial (exp), normal (norm), log-normal (lnorm), poisson (pois), t de Student (t), uniforme (unif), etc. Para cada una de estas distribuciones R ofrece funciones que nos permiten calcular cuatro tipos de valores vinculados a ellas: Valores de la función de densidad de probabilidad Valores de la función de distribución Cuantiles Muestras pseudoaleatorias de esas distribuciones Además, estas funciones utilizan un esquema de nombramiento homogéneo, para facilitar su uso. Así, si el nombre de la distribución es xxx (por ejemplo, norm para la distribución normal), los valores de la función de densidad de probabilidad se obtendrán con dxxx (dnorm), los de la función de distribución con pxxx (pnorm), los cuantiles con qxxx (qnorm) y las muestras pseudoaleatorias con rxxx (rnorm). Por ejemplo, para una distribución normal de media 0 y desviación típica 1: dnorm(0, mean=0, sd=1) # Densidad de probabilidad en 0 # [1] 0.3989423 pnorm(0, mean=0, sd=1) # Función de distribución en 0 # [1] 0.5 qnorm(0.25, mean=0, sd=1) # Cuantil 0.25 (primer cuartil) # [1] -0.6744898 rnorm(5, mean=0, sd=1) # 5 muestras pseudoaleatorias # [1] -0.4711529 -0.9017104 0.3270642 -1.1161598 -0.7629164 3.2.2 Estadística descriptiva Además de trabajar con distribuciones estadísticas teóricas, R nos permite analizar unos datos para caracterizarlos estadísticamente. Entre las funciones más habitualmente empleadas a la hora de llevar a cabo este tipo de análisis se encuentran: Función mean: Nos permite calcular la media. Función sd: Sirve para obtener la desviación estándar. Función var: Nos devuelve la varianza. Función quantile: Para obtener los cuantiles (por defecto, cuartiles, pero se puede configurar con el parámetro probs). Función median: Permite calcular la mediana de la muestra. Función summary: Devuelve un resumen con los principales estadísticos de los datos que se pasan como argumento. Podemos ver a continuación ejemplos de uso de estas funciones: datos&lt;-rnorm(100, mean=0, sd=1) mean(datos) # [1] -0.04541376 sd(datos) # [1] 0.9461041 var(datos) # [1] 0.895113 median(datos) # [1] -0.1267531 quantile(datos) # 0% 25% 50% 75% 100% # -1.6806238 -0.7602521 -0.1267531 0.5466689 2.5583851 quantile(datos, probs=seq(0,1,0.2)) # 0% 20% 40% 60% 80% 100% # -1.6806238 -0.9240561 -0.4597640 0.2103897 0.7079928 2.5583851 summary(datos) # Min. 1st Qu. Median Mean 3rd Qu. Max. # -1.68100 -0.76030 -0.12680 -0.04541 0.54670 2.55800 Además de obtener sus estadísticos básicos, se pueden caracterizar unos datos de manera gráfica. Tres de los procedimientos más utilizados para esto son la representación del histograma (que nos da una estimación de la función de densidad de probabilidad), la representación de la distribución acumulada empírica (que nos da una estimación de la función de distribución) y la representación del diagrama de caja (boxplot) de los datos. Para obtener estas representaciones gráficas en R, utilizaremos las siguientes funciones: La función boxplot dibuja el diagrama de caja, recibiendo como parámetro los datos a representar: datos&lt;-rnorm(100, mean=0, sd=1) boxplot(datos) Figura 3.1: Ejemplo de diagrama de caja. La función ecdf nos permite obtener la distribución acumulada empírica, que se puede dibujar a continuación mediante una llamada a la función plot (función genérica de representación gráfica en R, que veremos en temas posteriores): datos&lt;-rnorm(100, mean=0, sd=1) plot(ecdf(datos)) Figura 3.2: Ejemplo de representación de distribución acumulada empírica. La función hist representa el histograma. Los parámetros principales de esta función según la documentación de R son: x: los datos a representar en el histograma. breaks: sirve para especificar los límites de los intervalos en los que está dividido el eje-x del histograma. Suele tomar como valor un número (que indica cuántos intervalos del mismo tamaño se deben representar) o un vector (con los límites de los intervalos). freq: un valor lógico que indica si se deben representar en el eje-y frecuencias (TRUE) o probabilidades (FALSE). datos&lt;-rnorm(100, mean=0, sd=1) hist(datos, breaks=10, freq=F) Figura 3.3: Ejemplo de histograma. 3.2.3 Test estadísticos básicos Otra actividad que se suele realizar como parte del proceso de análisis estadístico de unos datos es enunciar hipótesis sobre esos datos y tratar de contrastar esas hipótesis por medio de test estadísticos. Este proceso de inferencia estadística también se puede realizar en R, como veremos en esta sección. 3.2.3.1 Test t Es uno de los más básicos y también de los más comúnmente utilizados. En R este test se implementa mediante la función t.test. A través de un test t podemos por ejemplo determinar si la media de una muestra empírica coincide o no con un valor indicado. Veamos un ejemplo: datos&lt;-rnorm(100, mean=1, sd=1) t.test(datos, mu=1) # One Sample t-test # # data: datos # t = 0.0613, df = 99, p-value = 0.9513 # alternative hypothesis: true mean is not equal to 1 # 95 percent confidence interval: # 0.7931953 1.2199846 # sample estimates: # mean of x # 1.00659 Como se puede ver, hemos generado un vector de datos aleatorios (100 muestras) siguiendo una distribución normal N(1,1) y hemos aplicado el test t para determinar si la media (parámetro mu) es igual a 1. Obtenemos los siguientes resultados: La línea t = 0.0613, df = 99, p-value = 0.9513 nos indica el valor del estadístico t, los grados de libertad del test (df) y el p-valor obtenido. El intervalo de confianza del 95% es 0.7931953, 1.2199846. La media estimada en la muestra es 1.00659. Por defecto el test se lleva a cabo con un nivel de confianza del 95% (se puede cambiar con el parámetro conf.level de la función t.test). Así pues, a tenor de los resultados obtenidos (p&gt;0.05, el intervalo de confianza estimado para la media contiene el valor 1), no podemos rechazar la hipótesis de que la media es 1. También podemos utilizar un test t para comprobar si las medias de dos muestras independientes del mismo tamaño son iguales: datos1&lt;-rnorm(100, mean=0, sd=1) datos2&lt;-rnorm(100, mean=1, sd=1) t.test(datos1, datos2, conf.level=0.99) # Welch Two Sample t-test # # data: datos1 and datos2 # t = -7.4744, df = 197.978, p-value = 2.446e-12 # alternative hypothesis: true difference in means is not equal to 0 # 99 percent confidence interval: # -1.5054492 -0.7281998 # sample estimates: # mean of x mean of y # -0.05670122 1.06012327 Se puede ver que, en este caso, el p-valor obtenido es muy pequeño y el valor 0 queda fuera del intervalo de confianza estimado para la diferencia de medias, con lo que se rechazaría la hipótesis de que las medias son iguales. 3.2.3.2 Test Chi-cuadrado Este test se suele utilizar cuando queremos saber si dos variables son o no independientes. La hipótesis nula (las variables son independientes) se rechazaría si el p-valor obtenido para el test es menor que un valor alfa que depende del nivel de confianza que nosotros queramos (en particular, alfa = 1  nivel de confianza). Por ejemplo, supongamos que tenemos el siguiente data frame que relaciona dos variables: las filas representan al tipo de fumador (M, muy frecuente; F, frecuente; O, ocasional; N, no fuma), las columnas al tipo de deportista (Frec, frecuente; Esp, esporádico) y los valores al número de personas de cada tipo: depFrec&lt;-c(7,87,12,9) depEsp&lt;-c(4, 102, 7, 8) tabla&lt;-data.frame(Frec=depFrec, Esp=depEsp) rownames(tabla)&lt;-c(&quot;M&quot;,&quot;N&quot;,&quot;O&quot;,&quot;F&quot;) tabla # Frec Esp # M 7 4 # N 87 102 # O 12 7 # F 9 8 Queremos saber si las variables «ser fumador» y «ser deportista» son o no independientes, para lo que llevaremos a cabo un test de Chi-cuadrado, que en R se implementa por medio de la función chisq.test: chisq.test(tabla) # Pearson&#39;s Chi-squared test # # data: tabla # X-squared = 3.2328, df = 3, p-value = 0.3571 Como se puede ver, el p-valor es 0.3571 por lo que si nuestro nivel de confianza es del 95% (y por tanto alfa = 1-0.95 = 0.05) no se cumple que el p-valor sea menor que alfa y, por tanto, no podemos rechazar la hipótesis nula de que las variables son independientes. Otro uso habitual del test de Chi-cuadrado es realizar contrastes de bondad de ajuste, en los que la hipótesis a contrastar es que los datos de una muestra se ajustan a un modelo estadístico dado. Por ejemplo, supongamos que tenemos un dado, y queremos saber si el dado ha sido manipulado o no. Podemos tirar un determinado número de veces el dado y obtener la frecuencia con la que se obtiene cada uno de los seis resultados, construyendo por ejemplo el siguiente data frame: dado # Freq # 1 20 # 2 19 # 3 20 # 4 25 # 5 20 # 6 46 A continuación comprobaríamos si esa muestra se ajusta a un modelo en el que cada una de las seis alternativas es igualmente probable (como cabría esperar en un dado no manipulado) utilizando un test de Chi-cuadrado: probs&lt;-rep(1, 6)/6 chisq.test(dado$Freq, p=probs) # Chi-squared test for given probabilities # # data: dado$Freq # X-squared = 22.08, df = 5, p-value = 0.0005056 Como se puede ver, en este caso el p-valor es muy pequeño con lo que rechazamos la hipótesis de que los datos se ajustan al modelo considerado (y podríamos sospechar que el dado ha sido efectivamente manipulado). Nótese que la función chisq.test lleva a cabo una u otra tarea dependiendo de los parámetros que recibe como entrada (en función de si los datos representan una tabla bidimensional -test de independencia- o un vector unidimensional -bondad de ajuste-). "],["introducción-a-la-minería-de-datos-con-r.html", "3.3 Introducción a la minería de datos con R", " 3.3 Introducción a la minería de datos con R La minería de datos tiene como objetivo tratar de descubrir patrones ocultos en conjuntos de datos. En las siguientes secciones veremos cómo se pueden realizar con R algunas tareas que se suelen llevar a cabo como parte del proceso de minería de datos. 3.3.1 Análisis de correlación A través del análisis de correlación podemos determinar si existe (alta correlación) o no (baja correlación) una relación lineal entre variables y en qué sentido se produce (correlación positiva o negativa). Para determinar si existe correlación entre dos variables utilizaremos la función cor.test de R, que calcula la correlación y un p-valor para estimar si esta es o no significativa (con un nivel de confianza del 95% se considera que si p&lt;0.05 la correlación es significativa, puesto que se rechazaría la hipótesis nula de que la correlación es cero). Por ejemplo, supongamos que disponemos del siguiente data frame que muestra en dos columnas la relación entre la temperatura medida en una determinada ciudad y las ventas (en euros) en un puesto de refrescos. tabla # temp ventas # 1 22.3 40.61 # 2 34.1 61.28 # 3 25.8 48.01 # 4 9.6 18.42 # 5 17.8 31.38 # 6 21.2 37.82 # 7 19.9 35.79 # 8 32.7 59.52 # 9 27.6 50.12 # 10 24.4 44.95 cor.test(tabla$temp, tabla$ventas) # Pearson&#39;s product-moment correlation # # data: tabla$temp and tabla$ventas # t = 51.7933, df = 8, p-value = 2.14e-11 # alternative hypothesis: true correlation is not equal to 0 # 95 percent confidence interval: # 0.9934703 0.9996617 # sample estimates: # cor # 0.9985122 Se puede ver que existe una alta correlación entre las variables (cor=0.99851) y además es positiva (cuando crece la temperatura esperaríamos que creciesen también las ventas). También podemos observar que el p-valor es muy pequeño, con lo que la correlación sería en este caso significativa. 3.3.2 Regresión El objetivo del análisis de regresión es el de encontrar una función que permita predecir los valores de una variable dependiente en base a los de una o varias variables independientes. Existen distintos tipos de análisis de regresión, dependiendo del tipo de función que queramos emplear, aunque en este tema nos centraremos en el caso en el que la función es una recta (regresión lineal), dado que es el más habitualmente empleado. Para calcular la recta de regresión a partir de unos datos utilizaremos la función lm de R. El principal argumento de esta función es una fórmula con la estructura: Donde VD representa la variable dependiente y VI las distintas variables independientes. Veamos un ejemplo: se trata de determinar si el número de veces que un grillo canta en una determinada unidad de tiempo (por ejemplo, minutos) guarda relación con la temperatura ambiente. Tras realizar una serie de medidas se ha llegado a los siguientes datos: temp &lt;- c(88.6, 71.6, 93.3, 84.3, 80.6, 75.2, 69.7, 82.0, 69.4, 83.3, 79.6, 82.6, 80.6, 83.5, 76.3) sonido &lt;- c(20.0, 16.0, 19.8, 18.4, 17.1, 15.5, 14.7, 17.1, 15.4, 16.2, 15.0, 17.2, 16.0, 17.0, 14.4) tabla &lt;- data.frame(temp, sonido) tabla # temp sonido # 1 88.6 20.0 # 2 71.6 16.0 # 3 93.3 19.8 # 4 84.3 18.4 # 5 80.6 17.1 # 6 75.2 15.5 # 7 69.7 14.7 # 8 82.0 17.1 # 9 69.4 15.4 # 10 83.3 16.2 # 11 79.6 15.0 # 12 82.6 17.2 # 13 80.6 16.0 # 14 83.5 17.0 # 15 76.3 14.4 Donde temp representa la temperatura en grados Fahrenheit y sonido el número de cantos por minuto. Podemos intentar ajustar un modelo lineal entre ambas variables haciendo: fit&lt;-lm(sonido~temp, data=tabla) fit # Call: # lm(formula = sonido ~ temp, data=tabla) # # Coefficients: # (Intercept) temp # -0.3091 0.2119 Donde, como se puede ver, se sugiere que la ecuación de la recta estimada es: sonido = 0.2119*temp  0.3091 Aunque hemos determinado la ecuación, no sabemos si el ajuste realizado es bueno o no. Para ello, podemos utilizar la función summary que nos ofrece más información sobre el ajuste: summary(fit) # Call: # lm(formula = sonido ~ temp, data = tabla) # # Residuals: # Min 1Q Median 3Q Max # -1.56009 -0.57930 0.03129 0.59020 1.53259 # # Coefficients: # Estimate Std. Error t value Pr(&gt;|t|) # (Intercept) -0.30914 3.10858 -0.099 0.922299 # temp 0.21193 0.03871 5.475 0.000107 *** # --- # Signif. codes: 0 *** 0.001 ** 0.01 * 0.05 . 0.1   1 # # Residual standard error: 0.9715 on 13 degrees of freedom # Multiple R-squared: 0.6975, Adjusted R-squared: 0.6742 # F-statistic: 29.97 on 1 and 13 DF, p-value: 0.0001067 Para interpretar estos resultados debemos fijarnos en varios aspectos: En Residuals se nos ofrece información sobre los residuos del ajuste. Estos residuos deberían seguir una distribución normal de media cero, así que la mediana de los residuos debería estar cerca de cero (aquí 0.03129) y el valor absoluto del mínimo y el máximo debería ser similar (ambos cerca de 1.5). Se nos indica también si los coeficientes estimados en el análisis son o no significativos por medio de un p-valor (última columna de la tabla Coefficients). Así se puede ver que el coeficiente estimado para tabla$temp (0.21193) sí lo es (p-valor muy pequeño), mientras que la estimación del punto de interceptación (-0.30914) tiene un p-valor alto (0.922299) con lo que no se puede considerar significativo. Los valores de R-squared sirven como medida de la bondad del ajuste. Para que el ajuste sea bueno, estos valores deberían estar próximos a 1. Por último, puede ser interesante en ocasiones hacernos una idea de la bondad del ajuste mediante la representación gráfica de los datos y la recta de regresión. Mediante la función abline podemos dibujar la recta de regresión, mientras que utilizaremos la función plot para representar los datos de la tabla: temp &lt;- c(88.6, 71.6, 93.3, 84.3, 80.6, 75.2, 69.7, 82.0, 69.4, 83.3, 79.6, 82.6, 80.6, 83.5, 76.3) sonido &lt;- c(20.0, 16.0, 19.8, 18.4, 17.1, 15.5, 14.7, 17.1, 15.4, 16.2, 15.0, 17.2, 16.0, 17.0, 14.4) tabla &lt;- data.frame(temp, sonido) fit&lt;-lm(sonido~temp, data=tabla) plot(tabla$temp, tabla$sonido) abline(fit) Figura 3.4: Representación gráfica del ajuste lineal de unos datos. 3.3.3 Clasificación La tarea de clasificación tiene como objetivo organizar una serie de datos en un conjunto de categorías predefinidas. En la práctica existen multitud de alternativas en lo que a algoritmos de clasificación se refiere, muchas de las cuales están implementadas en R a través de distintos paquetes. En esta sección haremos uso del paquete e1071, desarrollado por el Departamento de Estadística de la Universidad Tecnológica de Viena y que incluye la implementación de algunos mecanismos de clasificación de datos, tales como el algoritmo de Bayes ingenuo (Naive Bayes) o las máquinas de vectores soporte (Support Vector Machines, SVM). Para ello, instalaremos el paquete en nuestro sistema ejecutando en la consola de R: install.packages(&quot;e1071&quot;, dependencies=T) library(e1071) Para mostrar el uso de estas técnicas de clasificación necesitamos un conjunto de datos con el que hacer pruebas. En nuestro caso utilizaremos el denominado Iris Flower Dataset, un conjunto de datos sencillo que se suele emplear como ejemplo en tareas de clasificación. Tan frecuente es su uso que, de hecho, R incluye una copia de este conjunto de datos que podemos cargar ejecutando en el terminal el comando: data(iris) Lo que creará una variable de tipo data frame y nombre iris en el entorno. Podemos ver las primeras entradas de la tabla ejecutando el comando: head(iris) # Sepal.Length Sepal.Width Petal.Length Petal.Width Species # 1 5.1 3.5 1.4 0.2 setosa # 2 4.9 3.0 1.4 0.2 setosa # 3 4.7 3.2 1.3 0.2 setosa # 4 4.6 3.1 1.5 0.2 setosa # 5 5.0 3.6 1.4 0.2 setosa # 6 5.4 3.9 1.7 0.4 setosa Los datos de Iris se obtuvieron midiendo cuatro características (longitud y ancho del sépalo, longitud y ancho del pétalo, todos ellos expresados en centímetros) de una serie de especies vegetales (Iris setosa, Iris virgínica, Iris versicolor). Para cada una de las especies la tabla ofrece 50 muestras (filas en el data frame). Las técnicas de clasificación son técnicas supervisadas, en las que es necesario entrenar un clasificador para, posteriormente, utilizarlo a la hora de predecir la clase a la que pertenece una o varias muestras nuevas (no incluidas en el conjunto de entrenamiento). En nuestro caso, dividiremos el conjunto Iris en dos partes: una la usaremos para entrenar el clasificador (120 muestras, 40 de cada clase) y la otra para evaluarlo (30 muestras, 10 de cada clase): train&lt;-iris[c(1:40,51:90,101:140),] eval&lt;-iris[c(41:50,91:100,141:150),] dim(train) # [1] 120 5 dim(eval) # [1] 30 5 A continuación, entrenaremos el clasificador utilizando el conjunto de entrenamiento: nbClass &lt;- naiveBayes( Species ~ Sepal.Length+Sepal.Width +Petal.Length+Petal.Width, data = train) Donde estamos utilizando la función naiveBayes para entrenar un clasificador bayesiano ingenuo. El primer argumento representa una fórmula que indica que queremos predecir la clase indicada por Species utilizando como variables independientes el resto de columnas del data frame (esto se podría haber abreviado por un simple punto, con lo que podríamos escribir directamente Species ~ .). El segundo argumento indica de dónde sacamos los datos. Una vez entrenado el clasificador podemos utilizarlo para predecir la clase de cada una de las muestras del conjunto de evaluación mediante la función predict: predicted&lt;-predict(nbClass, eval[,-5]) Podemos obtener la matriz de confusión del clasificador utilizando la función table: matrizconf&lt;-table(predicted, eval$Species) matrizconf # predicted setosa versicolor virginica # setosa 10 0 0 # versicolor 0 10 0 # virginica 0 0 10 Y podemos obtener su tasa de aciertos haciendo: sum(diag(matrizconf))/sum(matrizconf) # [1] 1 Con lo que vemos que en este caso el clasificador ha acertado en todas las predicciones. Un proceso similar se seguiría para utilizar el clasificador SVM, aunque en este caso la función para entrenar el clasificador sería la función svm. En el ejemplo anterior del clasificador bayesiano ingenuo, hemos dividido los datos en entrenamiento y evaluación a mano, utilizando el operador de selección [] con los índices de los elementos que queremos añadir en cada grupo. Sin embargo, podríamos haber hecho la división de manera aleatoria utilizando las funciones: sample: permite extraer una muestra aleatoria de tamaño dado de un vector de elementos. split: permite dividir un conjunto de elementos en grupos, definidos mediante una variable categórica (factor). unsplit: realiza el proceso contrario a split, uniendo una serie de grupos en un único conjunto de elementos. Por ejemplo: datasets&lt;-split(iris, iris$Species) etiquetados&lt;-lapply( datasets, function(x) {s&lt;-sample(1:nrow(x), 10); x[s,&quot;t&quot;]&lt;-&quot;eval&quot;; x[-s,&quot;t&quot;]&lt;-&quot;train&quot;; return(x)}) dataset&lt;-unsplit(etiquetados, iris$Species) train&lt;-dataset[dataset$t==&quot;train&quot;,-6] eval&lt;-dataset[dataset$t==&quot;eval&quot;,-6] El primer comando utiliza la función split para dividir el data frame iris en base al valor de la columna Species. El data frame original se divide así en tres partes, una por cada especie (Setosa, Virgínica, Versicolor), obteniendo como resultado una lista con tres data frames. A cada uno de los elementos de esa lista se le aplica (con lapply) una función que selecciona aleatoriamente 10 entradas (con sample). Las entradas seleccionadas se etiquetan añadiendo una nueva columna t con valor eval mientras que el resto de entradas se marcan con el valor train en esa columna t. El siguiente comando usa unsplit para juntar los tres data frames ya etiquetados en uno solo. A continuación, los dos siguientes comandos utilizan el valor de la columna t para seleccionar las filas que constituirán el conjunto de entrenamiento y el de evaluación, eliminando al mismo tiempo esa misma columna t (la última, en la posición 6). 3.3.4 Agrupamiento (clustering) La tarea de agrupamiento tiene como objetivo organizar una serie de datos en grupos de forma que los más similares (de acuerdo a una métrica determinada) acaben en el mismo grupo. Al igual que ocurría con los algoritmos de clasificación, también existen múltiples algoritmos que podemos utilizar para agrupar unos datos. En esta sección veremos cómo utilizar uno de los más populares, el algoritmo k-means. En R el algoritmo k-means se implementa por medio de la función kmeans. Los dos parámetros principales de esta función son: x: Son los datos que queremos procesar (debe ser una matriz numérica) centers: En el que indicaremos el número de grupos en los que queremos repartir los datos. Tomemos por ejemplo los datos de Iris, y asumamos que no conocemos la clase a la que pertenece cada muestra (lo que podemos hacer eliminando la última columna): datos&lt;-iris[,-5] Podemos llevar a cabo un análisis de agrupamiento de estos datos utilizando la siguiente secuencia de comandos de R: m&lt;-as.matrix(datos) norm_m&lt;-scale(m) fit&lt;-kmeans(norm_m, 3) En donde se puede ver que primero convertimos el data frame en una matriz con la llamada a la función as.matrix, a continuación escalamos la matriz (función scale), de forma que se trate de manera homogénea a las distintas variables (haciendo que tengan misma media y desviación típica) y, por último, realizamos el agrupamiento, indicando que queremos tres grupos. Podemos a continuación acceder a los resultados del agrupamiento a través de la variable fit: fit$centers: Nos proporciona los centros de los agrupamientos. fit$cluster: Indica el grupo en el que se ha asignado cada muestra. Un parámetro de calidad del agrupamiento generado mediante el algoritmo de K-means se puede calcular mediante la expresión: fit$betweenss/fit$totss # [1] 0.7669658 Que se podría interpretar como que aproximadamente un 77% de la varianza de los datos queda explicada al hacer el agrupamiento. En general, cuanto mayor es este valor, mejor el agrupamiento, pero hay que tener en cuenta que el valor aumenta a medida que aumentamos el número de grupos, con lo que interesa encontrar un compromiso entre el parámetro de calidad y el número de grupos (y de hecho, esto se utiliza como un mecanismo para intentar estimar el número de grupos, a través del denominado «método del codo» Elbow Method). Además del parámetro de calidad, en nuestro caso podemos comparar las asignaciones a grupos con las clases iniciales que venían asignadas en Iris: table(fit$cluster, iris[,5]) # setosa versicolor virginica # 1 0 11 36 # 2 0 39 14 # 3 50 0 0 De donde podríamos deducir que el grupo 1 corresponde a la especie «virginica», el 2 a «versicolor» y el 3 a «setosa» y que el mecanismo se equivocaría en la asignación de 11+14=25 casos sobre un total de 150. "],["análisis-de-datos-con-r-ii.html", "Capítulo 4 Análisis de datos con R (II)", " Capítulo 4 Análisis de datos con R (II) Introducción y objetivos En el tema anterior presentamos una serie de técnicas básicas de análisis de datos con R. Estas técnicas estaban centradas en el análisis de datos de naturaleza numérica, normalmente recogidos en estructuras de datos complejas, como las tablas. Sin embargo, R también nos permite llevar a cabo el análisis de otros tipos datos mediante el uso de paquetes específicos. El objetivo fundamental de este tema es ofrecer una breve introducción a algunos de estos paquetes y familiarizarnos con el uso de los mismos a nivel básico. En particular, centraremos nuestra atención en dos aspectos: Aprenderemos a llevar a cabo tareas simples de minería de texto, utilizando para ello las funcionalidades ofrecidas por la librería tm (text mining). Presentaremos el paquete de extensión igraph, que nos permitirá llevar a cabo el análisis de información con estructura de grafo. Para ello, dividiremos el tema en dos secciones específicas, cada una de ellas dedicada a un paquete concreto. En cada una de estas secciones comenzaremos ofreciendo una breve introducción al paquete, con la finalidad de motivar y contextualizar su uso. A continuación, veremos cómo utilizar el paquete en la práctica, lo que incluirá tanto la creación de las estructuras de datos específicas para representar documentos de texto y grafos en R, como su manipulación, utilizando algunas de las técnicas de análisis disponibles en cada paquete. Así pues, cuando hayas finalizado con los contenidos de este tema: Habrás aprendido qué son y por qué son útiles las técnicas de minería de texto y análisis de grafos. Habrás instalado los paquetes necesarios (tm, igraph) en tu computador. Conocerás las principales estructuras de datos y funcionalidades ofrecidas por dichos paquetes. Sabrás cómo utilizarlos para llevar a cabo tareas básicas de minería de texto y análisis de grafos. "],["minería-de-texto.html", "4.1 Minería de texto", " 4.1 Minería de texto 4.1.1 Introducción Actualmente se generan diariamente grandes cantidades de información en formato textual: entradas de blogs, nuevas páginas web, mensajes en redes sociales, documentos en intranets corporativas, entradas en canales de distribución de información (feeds, listas de correo), etc. Para poder procesar esta información textual de una manera escalable se hace necesario el desarrollo de técnicas y herramientas que permitan automatizar la tarea mediante el uso de computadoras. El objetivo es reducir en la medida de lo posible la intervención humana (que suele ser costosa tanto económicamente como en tiempo de procesado) aunque sin eliminarla (dado que a fin de cuentas el análisis de la información textual responderá a las necesidades particulares de un usuario o grupo de usuarios). La minería de texto es un proceso en el que un usuario interactúa con una colección de documentos utilizando una serie de herramientas con la intención de obtener información útil para las necesidades del usuario. Para llevar a cabo tareas de minería de texto en R usaremos el paquete tm. Este paquete fue desarrollado en la University of Economics and Business de Viena (WU Vienna) por Ingo Feinerer como parte de su tesis doctoral: «A text mining framework in R and its applications», publicada en el año 2008. Básicamente, el objetivo del paquete es proporcionar un entorno dentro del lenguaje R para permitir el desarrollo de aplicaciones de minería de texto, incluyendo funcionalidades tales como: Procesamiento previo: importar datos y prepararlos (por ejemplo, eliminando espacios en blanco y signos de puntuación, troceando el texto en términos, etc.). Asociaciones: encontrar términos asociados a otro en base a la frecuencia con la que los términos concurren (se mencionan a la vez en el mismo documento). Agrupamiento: realizar agrupamiento (clustering) de documentos similares. Clasificación: organizar documentos en base a una lista de categorías previamente definidas. Resumen: resumir un texto en sus conceptos principales (que típicamente se definirán en base a los términos que se mencionen con mayor frecuencia). El paquete tm es software libre y gratuito. Para instalarlo en nuestro entorno de R simplemente debemos ejecutar desde la consola la expresión: install.packages(&quot;tm&quot;, dependencies=TRUE) Y a continuación, una vez instalado, cargar la librería en el entorno de R con: library(tm) Una vez hemos presentado brevemente el paquete tm y lo hemos instalado en nuestro ordenador, en la siguiente sección pasaremos a ver las estructuras de datos y funciones que implementa y a trabajar con él en la práctica. 4.1.2 Minería de texto con tm Normalmente toda de tarea de minería de texto se lleva a cabo mediante una serie de actividades o etapas: La tarea de minería de texto suele comenzar importando una serie de textos dentro de la herramienta con la que vamos a llevar a cabo el análisis. Una vez tenemos el texto importado en la herramienta, la siguiente etapa suele consistir en llevar a cabo una serie de tareas de procesamiento previo de ese texto, entre las que se pueden incluir actividades como: eliminación de espacios en blanco, eliminación de stopwords (palabras que no aportan significado al texto como artículos o conjunciones), etc. A continuación, a partir del resultado de la etapa de procesamiento previo, se suele construir una estructura de datos que facilite el análisis y procesamiento posterior de los textos. La estructura más habitualmente utilizada es la denominada matriz de términos-documentos (term-document matrix), que veremos más adelante. Finalmente, se lleva a cabo la tarea de análisis que nos interese utilizando la estructura de datos previamente construida. A continuación veremos cómo llevar a cabo cada una de estas etapas utilizando las funcionalidades ofrecidas por el paquete tm. 4.1.2.1 Importar texto La principal estructura de datos que ofrece tm para maneja conjuntos de documentos de texto es la que se conoce como corpus. Existen distintos mecanismos que podemos utilizar a la hora de crear un corpus, dependiendo de la fuente de datos que queramos utilizar: El mecanismo más sencillo es utilizar un vector de cadenas de caracteres como fuente de datos (VectorSource), donde cada una de las entradas del vector se considerará un documento distinto: docs&lt;-c(&quot;Un documento&quot;, &quot;Otro documento&quot;) c&lt;-Corpus(VectorSource(docs)) Sin embargo, también es posible utilizar como fuente de datos un directorio en el que existen una serie de ficheros (DirSource). Por ejemplo, si quisiésemos construir un corpus a partir de una colección de documentos de texto (con extensión txt) con codificación UTF-8 ubicada en la carpeta /Users/user1/corpus podríamos ejecutar en la consola de R la expresión: c&lt;-Corpus(DirSource(directory = &quot;/Users/user1/corpus&quot;, encoding=&quot;UTF-8&quot;, pattern = &quot;*.txt&quot;)) Una vez creado un corpus, se pueden utilizar una serie de operadores y funciones que el paquete tm ofrece para manipularlo. Entre las más relevantes figuran: El operador [] se puede utilizar para acceder a un subconjunto de los documentos de un corpus. El operador \\[\\[\\]] permite acceder a un documento concreto del corpus. La función c se puede utilizar para concatenar corpus. La función length devuelve la longitud (número de documentos) del corpus. La función content se puede utilizar para obtener el contenido de un documento del corpus. corpus1&lt;-Corpus(VectorSource(c(&quot;Un documento&quot;))) corpus2&lt;-Corpus(VectorSource(c(&quot;Otro documento&quot;))) unidos&lt;-c(corpus1, corpus2) length(unidos) # [1] 2 content(unidos[[2]]) # [1] &quot;Otro documento&quot; 4.1.2.2 Procesamiento previo Para llevar a cabo la etapa de procesamiento previo utilizaremos la función tm_map que nos va a permitir llevar a cabo transformaciones en los datos de un corpus. Básicamente, la función tm_map recibe los siguientes parámetros: El corpus sobre el que vamos a operar. Una función que queremos que se ejecute sobre el corpus. Esta función recibirá como entrada y devolverá como salida un documento de los incluidos en el corpus. Otros parámetros que pueda necesitar la función que queremos ejecutar. Veremos a continuación algunas de las transformaciones que se suelen llevar a cabo en la etapa de procesamiento previo utilizando el siguiente corpus como ejemplo: text&lt;-c(&quot;En un lugar de la Mancha de cuyo nombre no quiero acordarme&quot;, &quot;Miguel de Cervantes Saavedra (1547-1616)&quot;) corpus&lt;-Corpus(VectorSource(text)) 1. Normalizar el texto, convirtiendo todos los caracteres a minúsculas corpus &lt;- tm_map(corpus, content_transformer(tolower)) content(corpus[[2]]) # [1] &quot;miguel de cervantes saavedra (1547-1616)&quot; 2. Eliminar signos de puntuación corpus&lt;-tm_map(corpus, removePunctuation) content(corpus[[2]]) # [1] &quot;miguel de cervantes saavedra 15471616&quot; 3. Eliminar menciones a números corpus&lt;-tm_map(corpus, removeNumbers) content(corpus[[2]]) # [1] &quot;miguel de cervantes saavedra &quot; 4. Eliminar stopwords corpus&lt;-tm_map(corpus, removeWords, stopwords(&quot;spanish&quot;)) corpus[[2]] # [1] &quot;miguel cervantes saavedra &quot; Nótese que en este caso hemos utilizado un tercer argumento, para indicarle a la función removeWords la lista de palabras que debe eliminar (en este caso, las stopwords del español, aunque podríamos proporcionar también una lista propia). 5. Lematizar (stemming) los términos (encontrar su raíz) corpus&lt;-tm_map(corpus, stemDocument, &quot;spanish&quot;) content(corpus[[1]]) [1] {r eval=FALSE}&quot; lug manch cuy nombr quier acord&quot; La matriz de términos-documentos. Como su propio nombre indica, básicamente esta estructura consiste en una matriz cuyas filas representan diferentes términos y cuyas columnas representan documentos que mencionan esos términos. El valor numérico de las celdas de la matriz se puede calcular de distintas formas. Por ejemplo, puede consistir simplemente en la frecuencia del término en el documento (cuenta del número de veces que el término aparece en el documento), en la frecuencia normalizada (esto es, el número de veces que el término aparece en el documento dividido entre el número total de términos del documento), etc En tm podemos construir una matriz de términos-documentos directamente a partir de un corpus de documentos: docs&lt;-c(&quot;primer documento al principio&quot;, &quot;segundo documento tras el primer documento&quot;, &quot;tercer documento tras el segundo documento&quot;, &quot;cuarto documento&quot;) corpus&lt;-Corpus(VectorSource(docs)) tdm&lt;-TermDocumentMatrix(corpus) Podemos visualizar la matriz utilizando la función inspect: inspect(tdm) # &lt;&lt;TermDocumentMatrix (terms: 7, documents: 4)&gt;&gt; # Non-/sparse entries: 13/15 # Sparsity : 54% # Maximal term length: 9 # Weighting : term frequency (tf) # # Docs # Terms 1 2 3 4 # cuarto 0 0 0 1 # documento 1 2 2 1 # primer 1 1 0 0 # principio 1 0 0 0 # segundo 0 1 1 0 # tercer 0 0 1 0 # tras 0 1 1 0 Donde se puede ver que los valores numéricos de las celdas en este ejemplo consisten simplemente en la cuenta de menciones (frecuencia, term frequency) de cada término (Terms) en cada documento (Docs). Este comportamiento se puede cambiar a la hora de construir la matriz por medio del parámetro control y la propiedad weighting. Los valores más habitualmente empleados con esta propiedad son: weightBin: el valor es un 0 o un 1 dependiendo de si el término está o no en el documento. weitghTf: el valor de cada celda de la matriz es la frecuencia del término en el documento. Esta es la configuración por defecto, mostrada en el ejemplo anterior. weightTfIdf: el valor de cada celda se calcula como el producto de la frecuencia de término normalizada por la frecuencia inversa de documento inverse document frequency (IDF). El IDF se calcula como el logaritmo del cociente que resulta de dividir el número total de documentos del corpus entre el número de documentos que mencionan al término. Un ejemplo de uso de estos valores se muestra a continuación: tdmTfIdf&lt;-TermDocumentMatrix(corpus, control=list(weighting=weightTfIdf)) inspect(tdmTfIdf) # &lt;&lt;TermDocumentMatrix (terms: 7, documents: 4)&gt;&gt; # Non-/sparse entries: 9/19 # Sparsity : 68% # Maximal term length: 9 # Weighting : term frequency - inverse document frequency # (normalized) (tf-idf) # # Docs # Terms 1 2 3 4 # cuarto 0.0000000 0.0 0.0 1 # documento 0.0000000 0.0 0.0 0 # primer 0.3333333 0.2 0.0 0 # principio 0.6666667 0.0 0.0 0 # segundo 0.0000000 0.2 0.2 0 # tercer 0.0000000 0.0 0.4 0 # tras 0.0000000 0.2 0.2 0 Se puede observar en las matrices mostradas en los ejemplos anteriores que, a pesar de no haber eliminado explícitamente las stopwords del corpus, algunas de las palabras que aparecen en los documentos (por ejemplo, el y la) no se incluyen en la matriz de términos-documentos. Esto se debe a que, por defecto, al construir la matriz se eliminan los términos de menos de tres caracteres. Tareas de análisis. En este apartado trabajaremos con un pequeño conjunto de documentos que contienen noticias en inglés de la agencia Reuters. Estos documentos se distribuyen ya con el paquete tm y se pueden cargar en el entorno de R haciendo: data(acq) data(crude) corpus&lt;-c(acq,crude) Una vez importados los documentos, podemos aplicar algunas de las técnicas de procesamiento previo vistas con anterioridad, para preparar los datos para su análisis: corpus &lt;- tm_map(corpus, content_transformer(tolower)) corpus &lt;- tm_map(corpus, removeWords, stopwords(&quot;english&quot;)) corpus &lt;- tm_map(corpus, removePunctuation) corpus &lt;- tm_map(corpus, removeNumbers) A continuación veremos cómo llevar a cabo algunas operaciones típicas de minería de texto utilizando R, el paquete tm y este corpus. 4.1.3 Encontrar términos frecuentes En muchas ocasiones nos interesará poder encontrar rápidamente aquellos términos que consideramos más relevantes en un corpus o en un documento, que usualmente son aquellos que aparecen mencionados con mayor frecuencia (siempre que se hayan eliminado previamente las stopwords). Para ello podemos utilizar la función findFreqTerms. Por ejemplo, los términos que hayan aparecido al menos 25 veces en el corpus se obtendrían ejecutando: tdm&lt;-TermDocumentMatrix(corpus) findFreqTerms(tdm, 25) También podemos obtener una lista con las k palabras más frecuentes a partir de la matriz de términos-documentos haciendo (por ejemplo, para k=10): tf&lt;-rowSums(as.matrix(tdm)) tfordered&lt;-sort(tf, decreasing=TRUE) top10&lt;-tfordered[1:10] Donde primero calculamos la frecuencia agregada de cada término en todos los documentos del corpus (con rowSums), después ordenamos el resultado en orden descendente (con sort) y finalmente seleccionamos los primeros 10 elementos. Podemos representar gráficamente el resultado mediante una nube de etiquetas, que se construyen en R por medio de la función wordcloud del paquete del mismo nombre: install.packages(&quot;wordcloud&quot;, dependencies=TRUE) library(wordcloud) colors&lt;-gray((top10+1)/(max(top10)+1)) wordcloud(names(top10), top10, colors=colors) El resultado obtenido se puede ver en la Figura 1. Figura 1. Nube de etiquetas. 4.1.3.1 Buscar términos relacionados con otros En ocasiones nos interesará también poder obtener una lista de palabras que guardan relación con una dada. Para ello, el paquete tm ofrece la función findAssocs, que encuentra términos que se mencionan frecuentemente en compañía del término buscado (y tienen, pues, una alta correlación). Esta función toma tres argumentos: La matriz de términos-documentos con la que operar. El término del que queremos encontrar relacionados. Un valor numérico que sirve de umbral mínimo de correlación (los términos con correlación menor que esta, no se mostrarán). Veamos un ejemplo de uso, en el que se pueden ver las palabras del corpus que tienen una correlación de al menos 0.65 con share. findAssocs(tdm, &quot;share&quot;, 0.65) # $share # offer cash merger later offers dlrs # 0.74 0.70 0.68 0.66 0.66 0.65 4.1.4 Clasificación Otra tarea de minería de texto que se suele realizar con cierta frecuencia es la de intentar clasificar los documentos de un corpus en una serie de categorías predefinidas. Existen distintas técnicas que se pueden emplear para clasificar documentos. En nuestro caso utilizaremos una de las técnicas de clasificación más sencillas que se denomina KNN (K Nearest Neighbors). En concreto, la implementación de KNN que utilizaremos se proporciona en la librería class de R, que será necesario instalar y cargar en el entorno: install.packages(&quot;class&quot;, dependencies=TRUE) library(class) KNN es un algoritmo de clasificación supervisado, que necesita por tanto ser entrenado por medio de una serie de ejemplos para poder a continuación etiquetar apropiadamente nuevos documentos. Teniendo esto en cuenta, dividiremos nuestro corpus de ejemplo de Reuters en dos partes, una de entrenamiento y otra de evaluación, cada una de ellas conteniendo la mitad de los documentos de cada una de las dos categorías existentes: train&lt;-c(acq[1:25],crude[1:10]) trainClass&lt;-c(rep(&quot;acq&quot;,25), rep(&quot;crude&quot;,10)) test&lt;-c(acq[26:50],crude[11:20]) testClass&lt;-c(rep(&quot;acq&quot;,25), rep(&quot;crude&quot;,10)) corpus&lt;-c(train,test) Así pues, lo primeros 35 documentos del corpus serán los de entrenamiento (train) y los siguientes 35 los de evaluación (test). Nótese que hemos creado también vectores con la clase correcta en cada caso (trainClass, testClass) que utilizaremos con posterioridad. A continuación, haremos el procesamiento previo del corpus y construiremos la matriz de términos-documentos de tm, de la manera habitual: corpus &lt;- tm_map(corpus, content_transformer(tolower)) corpus &lt;- tm_map(corpus, removeWords, stopwords(&quot;english&quot;)) corpus &lt;- tm_map(corpus, removePunctuation) corpus &lt;- tm_map(corpus, removeNumbers) corpus &lt;- tm_map(corpus, stemDocument) tdm&lt;-TermDocumentMatrix(corpus) Transpondremos (con la función t) la matriz de términos-documentos para que la información relevante en este caso (los documentos) se represente en las filas, la convertiremos al tipo matriz de R (con as.matrix) y la normalizaremos, dividiendo cada una de las filas entre su norma euclídea: dtm&lt;-t(tdm) m &lt;- as.matrix(dtm) norm_eucl &lt;- function(m) m/apply(m, MARGIN=1, FUN=function(x) sum(x^2)^.5) m_norm &lt;- norm_eucl(m) A continuación, extraeremos dos submatrices, para entrenamiento y evaluación: trainm&lt;-m_norm[1:35,] testm&lt;-m_norm[36:70,] Provistos con esta entrada, estamos en condiciones de utilizar el clasificador KNN al que pasaremos tres argumentos: La matriz con los datos de entrenamiento. La matriz con los datos de evaluación. El vector que contiene las categorías correctas de los datos de entrenamiento. output&lt;-knn(trainm,testm,trainClass) El resultado almacenado en output contiene las clases estimadas por el clasificador KNN para el conjunto de evaluación. Podemos comparar este resultado con el valor esperado (vector testClass) para medir la calidad de nuestro clasificador. Para ello utilizaremos la función table para obtener la matriz de confusión del clasificador y, a partir de ella, calcularemos la tasa de aciertos del mismo: tabla&lt;-table(&quot;KNN&quot;=output,&quot;Correcta&quot;=testClass) tabla # Correcta # KNN acq crude # acq 25 1 # crude 0 9 # sum(diag(tabla))/sum(tabla) # [1] 0.9714286 Donde, como podemos ver, nuestro clasificador ha acertado en aproximadamente el 97% de los casos. "],["análisis-de-grafos.html", "4.2 Análisis de grafos", " 4.2 Análisis de grafos 4.2.1 Introducción En su forma más sencilla, un grafo (o red) se puede representar como una colección de puntos (denominados nodos o vértices) conectados por medio de líneas (denominadas enlaces o arcos). El interés por el análisis de grafos surge del hecho de que existen multitud de problemas en distintas áreas (física, biología, ciencias sociales, ciencias de la computación, etc.) que se pueden modelar matemáticamente por medio de grafos. Algunos ejemplos de grafos que aparecen en nuestra vida cotidiana incluyen: Internet (nodos - computadores; arcos - líneas de comunicación). La web (nodos - páginas web; arcos - hiperenlaces). Las redes sociales (nodos - personas; enlaces - relaciones entre ellas). La red de carreteras (nodos - ciudades; arcos - vías que las conectan). La red de metro (nodos - estaciones; arcos - vías que las conectan). Dadas las múltiples aplicaciones de los grafos como modelo matemático, disponer de técnicas y herramientas que permitan analizar estos grafos resulta de gran utilidad. Por ejemplo, podríamos estar interesados en analizar los grafos presentados anteriormente para aplicaciones tales como: Encontrar enlaces sensibles en la red de computadores, que en caso de caídas provoquen la desconexión de múltiples equipos. Hacer un ranking de páginas web para seleccionar las más relevantes (por ejemplo, las más enlazadas desde otras). Entender cómo se podría propagar una enfermedad analizando la estructura de contactos de una red social. Encontrar la ruta más corta entre dos ciudades en la red de carreteras o entre dos estaciones en la red de metro. El objetivo de este apartado es aprender a crear, manipular y analizar grafos utilizando R. Para ello nos apoyaremos en el paquete igraph, un proyecto de código libre al que han contribuido múltiples desarrolladores, entre los que destaca Gábor Csárdi, que actualmente trabaja en el Departamento de Estadística de la Universidad de Harvard. Comenzaremos por instalar el paquete, siguiendo el procedimiento habitual: install.packages(&quot;igraph&quot;, dependencies=T) Una vez instalado el paquete, cargaremos la librería en el entorno de R, ejecutando: library(igraph) Hecho esto, estamos en condiciones de poder empezar a usar las funcionalidades ofrecidas por igraph. 4.2.2 Primeros pasos con igraph El primer paso para trabajar con esta librería suele ser definir el grafo sobre el que vamos a operar. El modelo de datos de igraph da soporte a dos tipos fundamentales de grafos: Grafos dirigidos: Son aquellos en los que los arcos que unen dos vértices tienen un solo sentido. Un ejemplo de grafo dirigido serían los enlaces en la web, que nos llevan en una sola dirección, de la página de origen a la de destino del enlace. Grafos no dirigidos: Son aquellos en los que los arcos que unen dos vértices no tienen un único sentido y se pueden recorrer en ambos. Un ejemplo serían las redes de comunicaciones, que son usualmente bidireccionales (la información puede fluir en los dos sentidos). La forma más sencilla de crear un grafo, es llamando a la función graph y proporcionando directamente desde el terminal la lista de arcos que constituyen el grafo. Por ejemplo, ejecutando en la consola la expresión: g &lt;- graph( c(1,2, 2,3, 1,3, 1,4, 4,4) ) Estaríamos creando un grafo con cuatro vértices V={1,2,3,4} y cinco arcos E={(1,2),(2,3),(1,3),(1,4),(4,4)}. Internamente igraph utiliza identificadores enteros y secuenciales para referirse a los vértices (en el caso de R, el primer identificador debe ser el 1). Por eso, a la hora de crear el grafo, nosotros hemos seguido este convenio. Nótese que en la expresión anterior se han introducido espacios en blanco para que se vean los pares que constituyen cada arco. Obviamente estos espacios no son obligatorios. Una vez el grafo ha sido construido, podemos obtener un listado de los vértices y arcos que lo constituyen utilizando las funciones V (para vértices -vertex-) y E (para arcos - edges-): V(g) # + 4/4 vertices: # [1] 1 2 3 4 E(g) # + 5/5 edges: # [1] 1-&gt;2 2-&gt;3 1-&gt;3 1-&gt;4 4-&gt;4 Puede verse que el grafo resultante es un grafo dirigido (indicado con -&gt; en los arcos). Este es el comportamiento por defecto de la función graph. Podríamos especificar que el grafo fuese no dirigido mediante el parámetro directed: g &lt;- graph( c(1,2,2,3,1,3,1,4,4,4), directed=FALSE) E(g) # + 5/5 edges: # [1] 1--2 2--3 1--3 1--4 4--4 También es posible añadir atributos a los vértices y arcos de un grafo. Estos atributos tienen múltiples aplicaciones, por ejemplo, a la hora de representar el grafo. Los atributos más comúnmente utilizados son: El atributo name: permite añadir etiquetas textuales a los vértices y arcos, para facilitar su interpretación. El atributo weight que se utiliza para asignar pesos numéricos a los vértices y a los arcos. Esto es útil por ejemplo para poder representar grafos ponderados (weighted graphs) en los que a los arcos se etiquetan con un peso (usualmente un número real). Este peso sirve, por ejemplo, para representar el coste de recorrer un enlace (p.ej.: la distancia en kilómetros al modelar carreteras) o su capacidad (útil por ejemplo al modelar redes de comunicaciones). El atributo color que permite especificar el color con el que se representarán gráficamente vértices y arcos. Podemos ver a continuación un ejemplo de uso de estos atributos: g &lt;- graph( c(1,2,2,3,1,3,1,4,4,4)) V(g)$name&lt;-c(&quot;Ana&quot;,&quot;Berto&quot;,&quot;Carlos&quot;,&quot;David&quot;) V(g)$weight&lt;-c(4.0,6.2,7.1,3.1) V(g)$color&lt;-c(&quot;green&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;yellow&quot;) E(g)$weight&lt;-c(1.0, 0.2, 2.3, 6.1, 0.4) E(g)$name&lt;-E(g)$weight E(g)$color&lt;-rep(&quot;red&quot;,5) plot(g, edge.width=E(g)$weight, edge.label=E(g)$name, vertex.size=V(g)$weight*10, vertex.label=V(g)$name) Donde se puede ver el uso de la función plot a la hora de representar gráficamente el grafo, obteniéndose el resultado mostrado en la siguiente Figura. Figura 2. Representación gráfica de un grafo. Nótese que en la llamada a plot hemos configurado el tamaño de los vértices (vertex.size) el ancho de los arcos (edge.width), las etiquetas de los vértices (vertex.label) y las etiquetas de los arcos (edge.label). Información más detallada sobre la presentación de grafos con igraph puede obtenerse a través de la ayuda de R ejecutando la expresión: ?igraph.plotting 4.2.3 Importando/exportando grafos desde/a fichero Crear un grafo directamente a través de la consola de R, como hemos hecho en todos los ejemplos anteriores, es un mecanismo efectivo cuando trabajamos con grafos pequeños. Sin embargo, cuando el número de vértices y arcos en el grafo es elevado, resulta más habitual que tengamos la información en un fichero y que carguemos los datos del mismo utilizando la función read.graph de igraph. Esta función permite importar datos desde ficheros de distintos formatos, dos de los más utilizados debido a su sencillez son: Lista de arcos (edge list). Básicamente se trata de un fichero de texto en el que cada línea representa un arco del grafo, descrito por medio de dos identificadores numéricos separados por un espacio en blanco o tabulador. Por ejemplo, si tenemos un fichero /Users/user/grafo.elist. 0 1 0 2 1 2 0 3 3 3 Podemos crear un grafo a partir de él con ejecutando la expresión: g2&lt;-read.graph(&quot;/Users/user/grafo.elist&quot;, format=&quot;edgelist&quot;, directed=T) Un pequeño aspecto a considerar cuando trabajamos con este tipo de ficheros es que en este caso igraph espera que el primer identificador de vértice en el fichero sea un 0 y añadirá automáticamente un 1 a todos los identificadores, para cumplir con la restricción de que el primero sea el 1. LGL ncol. De nuevo consiste en un fichero de texto en el que cada línea representa un arco, con dos etiquetas textuales separadas por espacio en blanco y un tercer elemento opcional que representa el peso asociado al arco. Las etiquetas textuales se cargarán en el atributo name de los vértices, mientras que el valor de la última columna se incluirá en el atributo weight de los arcos y la librería asignará automáticamente un identificador entero a cada vértice. Por ejemplo, si tenemos un fichero /Users/user/grafo.ncol Ana Berto -0.3 Ana Carlos 2.4 Berto Carlos 9.2 Ana David -2.45 David David Podemos crear un grafo a partir de él con ejecutando la expresión: g3&lt;-read.graph(&quot;/Users/user/grafo.ncol&quot;, format=&quot;ncol&quot;, directed=T) Además de importar grafos desde fichero, también es posible exportarlos, utilizando la función write.graph a la que hay que indicarle el grafo a almacenar, la ruta del fichero destino y el formato en el que se desea representar el fichero. Por ejemplo: write.graph(g2, &quot;/Users/user/output.ncol&quot;, format=&quot;ncol&quot;) 4.2.4 Análisis de grafos con igraph Tras haber introducido las funcionalidades básicas ofrecidas por el paquete igraph, veremos a continuación cómo llevar a cabo algunas tareas de análisis de grafos de uso común. Para ello, trabajaremos con el grafo que representa la estructura de las líneas de metro de Madrid. Descarga a través del aula virtual el fichero con los datos del grafo para realizar el ejemplo: metro.ncol Si editáis el fichero, veréis que utiliza el formato LGL ncol, que tratamos con anterioridad, así que simplemente podéis cargarlo en vuestro entorno de R haciendo (reemplazando adecuadamente /path/to/ por la ruta en vuestro sistema): metro&lt;-read.graph(&quot;/path/to/metro.ncol&quot;, format=&quot;ncol&quot;, directed=FALSE) 4.2.5 Información básica de grafos Veremos a continuación una serie de ejemplos que muestran algunas de las funciones más utilizadas a la hora de obtener información básica sobre la estructura de un grafo. Más información sobre cada una de estas funciones individuales se puede obtener a través de la ayuda de R. Obtener el tamaño de un grafo (número de vértices y arcos): length(V(metro)) # [1] 275 length(E(metro)) # [1] 314 Saber si el grafo es conexo (existe al menos una ruta entre cualquiera dos nodos) o no: is_connected(metro) # [1] TRUE Listar los vecinos de un vértice dado (por ejemplo, la parada de Plaza de España) y obtener sus nombres: vecinos&lt;-neighbors(metro, &quot;Plaza_de_España&quot;) V(metro)[vecinos]$name # [1] &quot;Tribunal&quot; &quot;Callao&quot; &quot;Ventura_Rodríguez&quot; &quot;Príncipe_Pío&quot; Obtener el diámetro del grafo (distancia máxima entre dos de sus vértices): diameter(metro) # [1] 44 Medir la longitud media de las rutas que conectan los nodos dos a dos: mean_distance(metro) # [1] 15.61186 Consultar la densidad del grafo, que mide la relación entre el número de arcos que existen y el número total de los que podrían existir si todos los nodos estuviesen directamente conectados dos a dos: edge_density(metro) # [1] 0.008334439 Nótese que el grafo de ejemplo que nosotros estamos utilizando es un grafo no dirigido. Cuando el grafo es dirigido, puede ser necesario indicarles a algunas de las funciones anteriores (como por ejemplo a neighbors) con qué enlaces queremos operar. Es por eso por lo que un parámetro común en muchas de las funciones de igraph es el parámetro mode, que puede tomar tres valores: all: Si queremos que se tengan en cuenta todos los arcos in: Para considerar solo los incidentes en el nodo out: Para los que salen del nodo. 4.2.6 Medidas de centralidad Las medidas de centralidad son un indicador de la importancia relativa de un nodo dentro de un grafo en base a la posición que este nodo ocupa dentro de la red. Normalmente, cuanto mayor sea la centralidad del nodo, más importante será este. Existen cuatro métricas que se utilizan muy habitualmente a la hora de estimar la centralidad de los vértices de un grafo: Cercanía (closeness): dado un vértice, se calcula la distancia más corta desde ese vértice a todos los otros nodos de la red. A continuación se obtiene la media de esas distancias. La inversa de esa media es la cercanía. Por tanto, cuanto más pequeño es ese valor más alejado de otros nodos está el vértice y menor es su importancia. La cercanía se calcula en R con: closeness(metro, &quot;Plaza_de_España&quot;) # Plaza_de_España # 0.0003706449 Intermediación (betweenness): su objetivo es estimar cuántas veces un vértice aparece en el camino más corto que une otros dos vértices cualesquiera del grafo. Por tanto, cuanto mayor sea el betweenness, más importante será el nodo, puesto que más caminos pasarán a través de él. En igraph la intermediación de un nodo se calcula como: betweenness(metro, &quot;Plaza_de_España&quot;) # Plaza_de_España # 12054.46 Centralidad de grado (degree centrality): consiste simplemente en medir cuántos enlaces posee un nodo. Cuanto mayor sea este número, mejor conectado (y por tanto más importante) será el vértice. En igraph el grado de los nodos de un grafo se puede obtener con: degree(metro, &quot;Plaza_de_España&quot;) # Plaza_de_España # 4 PageRank: al igual que la centralidad de grado, tiene en cuenta el número de enlaces de un vértice, pero a diferencia de esta, no considera igualmente relevantes a todos los enlaces, sino que da más importancia a los enlaces con nodos que a su vez están bien conectados. Cuanto mayor es el valor de PageRank de un nodo, más relevante es. Se calcula en igraph con: page_rank(metro, vid=&quot;Plaza_de_España&quot;)$vector # Plaza_de_España # 0.004631253 4.2.7 Camino más corto Un problema que surge habitualmente al analizar grafos es encontrar el camino de menor coste entre dos nodos. Para resolver este problema, el paquete igraph implementa la función shortest_paths. Por defecto, shortest_paths utiliza el valor del atributo weight de cada arco para determinar su coste. Cuando un grafo no tiene atributo weight se toma como coste de un camino su número de saltos, con lo que esta función se puede utilizar también para calcular el camino más corto. Por ejemplo, podemos encontrar la ruta más corta entre las estaciones de Callao y Batán ejecutando en la consola de R: path&lt;-unlist(shortest_paths(metro, from=&quot;Callao&quot;, to=&quot;Batán&quot;)$vpath) V(metro)[path]$name # [1] &quot;Callao&quot; &quot;Plaza_de_España&quot; &quot;Príncipe_Pío&quot; &quot;Lago&quot; &quot;Batán&quot; # datos. "],["gráficos-y-visualización-de-datos.html", "Capítulo 5 Gráficos y visualización de datos", " Capítulo 5 Gráficos y visualización de datos Introducción y objetivos En temas anteriores hemos visto que R no solo nos permite manipular y analizar datos, sino que también ofrece mecanismos para representar visualmente esos datos a través de funciones como plot, hist o boxplot. Este tipo de representaciones resultan de gran utilidad, tanto en la etapa de análisis de datos (por ejemplo, para detectar visualmente patrones o anomalías) como a la hora de comunicar los resultados y conclusiones del análisis. Dada su importancia, dedicaremos este último tema a estudiar con más detalle las funcionalidades gráficas de R, incluyendo aspectos tales como: La creación de gráficos básicos con R. Cómo podemos personalizar esos gráficos (cambiar por ejemplo los colores, el tipo de línea, añadir una leyenda, etc.). Describir los mecanismos que nos van a permitir añadir varios gráficos en una misma figura. Cómo exportar los gráficos a fichero. Interacción básica con gráficos. Así pues, cuando termines este tema deberás ser capaz de llevar a cabo representaciones gráficas en R y configurarlas de la manera que consideres más apropiada, así como exportarlas para poder incluirlas en presentaciones, documentos, etc. "],["creando-gráficos-básicos-con-r.html", "5.1 Creando gráficos básicos con R", " 5.1 Creando gráficos básicos con R El mecanismo más habitualmente empleado a la hora de crear un gráfico en R es utilizar la función plot. Se trata de una función genérica, que puede ser utilizada para representar distintos tipos de datos (y cuya salida varía en función del tipo de datos que recibe para su representación). En su forma más simple, esta función recibe como entrada dos vectores de datos numéricos, que representan, respectivamente, las coordenadas x e y de los puntos a representar. Si ejecutamos en la consola: x&lt;-seq(1, 10) y&lt;-log(x) plot(x, y) Figura 5.1: Ejemplo de representación gráfica con plot. Se puede ver que, por defecto, plot representa lo que se denomina un gráfico de dispersión o scatter plot, es decir, simplemente representa los pares de puntos de las dos variables asociadas a los ejes (x e y), y no trata de unir estos puntos. En apartados posteriores veremos cómo cambiar este comportamiento. Un aspecto que debemos tener en cuenta a la hora de utilizar plot es que si al llamar a la función existe una ventana gráfica abierta, esta se reutilizará (y perderemos el gráfico anterior). Para evitar este comportamiento, podemos crear una nueva ventana antes de dibujar el gráfico utilizando la función dev.new. x&lt;-seq(1, 10) y1&lt;-log(x) y2&lt;-log(x)+1/x plot(x, y1) dev.new() plot(x, y2) Además de plot otras funciones comúnmente utilizadas para realizar representaciones gráficas en R son: hist: Representar un histograma. boxplot: Dibujar un diagrama de caja. barplot: Realizar un diagrama de barras. pie: Representar un gráfico circular. Al igual que ocurría con plot, estas funciones también reescriben la ventana gráfica, con lo que deberemos usar dev.new para abrir ventanas distintas para cada gráfico. Podemos ver a continuación ejemplos de uso de algunas de estas funciones: datos&lt;-c(0.25,0.50,0.15,0.10,0.25) nombres&lt;-paste(&quot;Grupo&quot;, seq(1,5)) pie(datos, labels=nombres) Figura 5.2: Ejemplo de gráfico circular. datos&lt;-c(0.25,0.50,0.15,0.10,0.25) nombres&lt;-paste(&quot;Grupo&quot;, seq(1,5)) barplot(datos, names.arg=nombres) Figura 5.3: Ejemplo de diagrama de barras. Se puede ver que los argumentos recibidos como entrada varían de función a función, por lo que la ayuda de R nos puede ser de gran utilidad en este sentido. A la hora de crear un gráfico, suele ser también necesario etiquetar adecuadamente la información de los ejes, así como especificar un título oportuno para la figura. Para esta finalidad resulta de especial relevancia la función title, que permite especificar un título para la figura así como etiquetar los ejes de la misma: x&lt;-seq(1,10) y&lt;-log(x) plot(x,y, ann=FALSE) title(main=&quot;La función logaritmo&quot;, sub=&quot;Subtítulo&quot;, xlab=&quot;Variable X&quot;, ylab=&quot;Variable Y&quot;) Figura 5.4: Ejemplo de uso de la función title. Se puede ver que hemos añadido el parámetro ann con valor FALSE en la llamada a plot. Esto impide que se añadan las etiquetas por defecto para los ejes (puesto que las vamos a configurar nosotros con la llamada posterior a title). También podríamos haber añadido directamente la configuración relativa al título y los ejes mediante parámetros de la función plot (en cuyo caso no sería necesario el parámetro ann) con lo que el código siguiente sería equivalente al anterior: x&lt;-seq(1,10) y&lt;-log(x) plot(x,y, main=&quot;La función logaritmo&quot;, sub=&quot;Subtítulo&quot;, xlab=&quot;Variable X&quot;, ylab=&quot;Variable Y&quot;) Figura 5.5: Ejemplo de uso de la función title. "],["personalización-de-gráficos.html", "5.2 Personalización de gráficos", " 5.2 Personalización de gráficos En muchas ocasiones nos interesará cambiar la presentación por defecto que R utiliza a la hora de dibujar un gráfico. Afortunadamente, R nos permite cambiar esta configuración por defecto y personalizar la apariencia de nuestros gráficos. A lo largo de esta sección veremos cómo, utilizando para ello ejemplos de uso de la función plot (aunque muchos de los parámetros que veremos se pueden utilizar también con otras funciones gráficas, como se puede comprobar consultando la documentación de R). Existen básicamente dos mecanismos que podemos utilizar a la hora de configurar los parámetros gráficos: La función par se utiliza si queremos cambiar los parámetros durante la sesión (es decir, una vez establecidos los parámetros, mientras no se cambien de nuevo o se cierre la sesión se utilizarán a la hora de dibujar nuestros gráficos). Utilizando los parámetros gráficos directamente como argumentos a la hora de llamar a las funciones de representación (en ese caso los parámetros se utilizarán sólo en esa llamada). En los siguientes apartados veremos ejemplos de cómo utilizar estos dos mecanismos alternativos a la hora de configurar distintos aspectos de la apariencia de un gráfico. 5.2.1 Símbolos y líneas Como indicamos en apartados anteriores, por defecto plot dibuja un diagrama de dispersión de los datos. Sin embargo, es posible configurar la función para que utilice líneas uniendo los puntos y para que cambie el tipo de línea y el tipo de punto. Para ello se utilizan principalmente cuatro parámetros gráficos: pch: configuración del tipo de punto (valor numérico entero o carácter). Figura 6. Códigos de los tipos de puntos. Fuente: http://www.cookbook-r.com/Graphs/Shapes_and_line_types/ cex: configuración del tamaño del punto (escala numérica relativa, por defecto valor 1; así el valor 1.5 indica que el tamaño será un 50% mayor que el valor por defecto). lty: se utiliza para especificar el tipo de línea (valor numérico entero o carácter). lwd: define el ancho de línea (valor numérico relativo, como cex). Podemos ver a continuación ejemplos de uso de estos parámetros: x&lt;-seq(1,10) y&lt;-log(x) plot(x, y, type=&quot;b&quot;, pch=2, cex=1.2, lty=3, lwd=1.2) Figura 5.6: Cambiando el tipo de línea y de punto. Se puede ver que hemos utilizado además el parámetro type de plot que permite especificar el tipo de representación gráfica (los valores más usados son «p» dibujar sólo puntos; «l», solo líneas y «b» puntos y líneas, como en este caso). Nótese que en este ejemplo hemos incluido los parámetros gráficos directamente como argumentos de entrada de la función plot. Sin embargo, es también posible utilizar la función par, como indicamos anteriormente: parViejo&lt;-par(no.readonly=TRUE) # (1) par(pch=2, cex=1.2, lty=3, lwd=1.2) # (2) plot(x,y, type=&quot;b&quot;) # (3) Figura 5.7: Cambiando el tipo de línea y de punto. par(parViejo) # (4) Donde, como se puede ver, comenzamos salvando dentro de la variable parViejo los valores de parámetros gráficos previamente existentes llamamos a continuación a la función par para establecer la nueva configuración gráfica dibujamos los gráficos necesarios (si fueran varios, utilizarían la configuración indicada por par) y por último restauramos la configuración previa (si lo creemos necesario). 5.2.2 Colores Otro parámetro gráfico que es posible configurar es el color utilizado para representar la información. Los principales parámetros relacionados con este aspecto de configuración son: col: Color que se utiliza para dibujar el gráfico. col.lab: Color para las etiquetas de los ejes. col.main: Color para el título. col.sub: Color para el subtítulo. A la hora de especificar los colores tenemos varias alternativas, las más usualmente utilizadas son: Utilizando un nombre de color (la lista de nombres de colores disponibles se puede obtener con una llamada a la función colors). Utilizando un código RGB (Red, Green, Blue) en hexadecimal (Ej.: #FFAA11) o en decimal (Ej.: rgb(128, 100, 32)). Existen funciones que permiten obtener los códigos de colores relacionados (Ej.: gray o heat.colors): gray(seq(1,4)/4) # 4 colores de la escala de grises # [1] &quot;#404040&quot; &quot;#808080&quot; &quot;#BFBFBF&quot; &quot;#FFFFFF&quot; heat.colors(4) # 4 colores &#39;cálidos&#39; # [1] &quot;#FF0000FF&quot; &quot;#FF8000FF&quot; &quot;#FFFF00FF&quot; &quot;#FFFF80FF&quot; Podemos ver un ejemplo de configuración de los colores de un gráfico a continuación: x&lt;-seq(1,10) y&lt;-log(x) plot(x,y,type=&#39;b&#39;, col=&quot;blue&quot;, col.lab=rgb(0.4,0.4,0.4), col.main=&#39;#04B404&#39;, main=&quot;Función logaritmo&quot;) Figura 5.8: Ejemplo de uso de colores en un gráfico. 5.2.3 Límites de los ejes En ocasiones nos puede interesar centrar nuestra representación en un área concreta para destacar ciertos aspectos del gráfico. Para ello podemos utilizar los parámetros xlim e ylim que nos permiten especificar los límites (tanto en el eje x como en el y) del área (rectangular) que va a ser representada. Estos parámetros suelen tomar como valor un vector de dos números (el inicio y el fin del intervalo que queremos que se muestre): x&lt;-1:100 y&lt;-log(sin(x)^2) plot(x,y, type=&#39;b&#39;, xlim=c(10,50), ylim=c(-4,2)) Figura 5.9: Definiendo los límites de los ejes. 5.2.4 Leyendas y texto Para hacer más legible una representación gráfica podemos pensar en añadir una leyenda explicativa o incluso en etiquetar ciertos puntos del gráfico de especial relevancia. La función legend nos permite añadir una leyenda. A través de los parámetros de esta función especificaremos la posición del cuadro de la leyenda (usualmente se indican las coordenadas x e y de la esquina superior izquierda del cuadro), su título (parámetro title) y las etiquetas de cada entrada de la leyenda (parámetro legend). x&lt;-1:100 y&lt;-log(x) plot(x, y, type=&quot;b&quot;,pch=1, lty=1, col=&quot;blue&quot;, main=&quot;La función logaritmo&quot;) legend(x=60,y=2, pch=1, lty=1, col=&quot;blue&quot;,title=&quot;Leyenda&quot;, legend=&quot;Logaritmo&quot;) Figura 5.10: Uso de leyenda en un gráfico. La función text se utiliza cuando queremos etiquetar uno o varios puntos de la gráfica. Recibe usualmente como parámetros los valores x e y de los puntos a etiquetar, y las etiquetas a añadir en cada punto (parámetro labels). x&lt;-1:100 y&lt;-log(sin(x)^2) min(y) # [1] -9.45438 which(y==min(y)) # [1] 22 x&lt;-1:100 y&lt;-log(sin(x)^2) plot(x, y, col=&#39;blue&#39;, type=&#39;b&#39;, pch=2, lty=4, ylim=c(-12,2)) text(x=c(22), y=c(-10), labels=c(&quot;Mínimo&quot;)) Figura 5.11: Etiquetando puntos de un gráfico. En ocasiones podemos estar interesados también en utilizar expresiones matemáticas dentro de las etiquetas de nuestros gráficos. Para ello crearemos una expresión de R (con la función expression) que pasaremos como argumento en los parámetros que representen las etiquetas. Así por ejemplo, sabemos que podemos utilizar el parámetro main para establecer el título de un gráfico. Pues bien, si queremos que el título contenga una expresión matemática podemos hacer: x&lt;-1:100 y&lt;-log(x+x^2) plot(x, y, col=&#39;blue&#39;, type=&#39;b&#39;, main = expression(paste(&quot;Función log(&quot;, x+x^2, &quot;)&quot;))) Figura 5.12: Ejemplo de expresión matemática en el título. Se puede encontrar más información sobre el formato que tenemos que utilizar para representar las expresiones en la ayuda de R con ?plotmath. 5.2.5 Añadiendo una rejilla Añadiendo una rejilla a un gráfico tendremos una serie de referencias con las que comparar la información ofrecida por el gráfico. En R podemos dibujar una rejilla utilizando la función grid. A través de los parámetros nx y ny podemos indicar el número de líneas que tendrá la rejilla en cada eje de coordenadas (si no especificamos nada, se dibujarán líneas coincidiendo con los puntos etiquetados en los ejes). Además, al igual que plot, podemos utilizar también en esta función los parámetros col, lty y lwd para establecer el color, el tipo de línea y el ancho de línea de la rejilla. Veamos un ejemplo: x&lt;-1:100 y&lt;-log(x) plot(x,y,col=&#39;blue&#39;,type=&#39;b&#39;) grid(col=&#39;red&#39;, lty=&#39;dashed&#39;, lwd=0.5) Figura 5.13: Ejemplo de gráfico con rejilla. "],["combinando-gráficos.html", "5.3 Combinando gráficos", " 5.3 Combinando gráficos Hasta ahora en todos los ejemplos del tema hemos representado únicamente un gráfico en cada figura. Sin embargo, R nos permite también combinar varios gráficos en una sola figura o combinar varias figuras independientes en una sola. Si lo que queremos es combinar varios gráficos en una sola figura podemos echar mano de funciones que permiten dibujar nueva información en una ventana gráfica previamente existente superponiendo gráficos. Ejemplos de este tipo de funciones son abline (para dibujar líneas de referencia), points (para dibujar puntos) o lines (para dibujar líneas en general). x&lt;-1:10 y1&lt;-log(x) y2&lt;-log(x)+(1/x) y3&lt;-log(x)+(1/log(x)) plot(x, y1, pch=3, type=&quot;b&quot;, col=&quot;blue&quot;, main=&quot;Varias gráficos juntos&quot;, xlab=&quot;x&quot;, ylab=&quot;y&quot;, ylim=c(0,4)) lines(x, y2, pch=2, type=&quot;b&quot;, col=&quot;red&quot;) points(x, y3) abline(h=1.3, col=&quot;black&quot;, lty=&#39;dotted&#39;) # Una línea horizontal en y=1.3 abline(v=7, col=&quot;#04B404&quot;, lty=2) # Una línea vertical en x=7 Figura 5.14: Combinando varios gráficos en la misma figura. También podemos combinar varias figuras independientes en una sola utilizando la función par: x&lt;-1:100 y1&lt;-log(x) y2&lt;-log(sin(x)^2) par(mfrow=c(2,2)) plot(x, y1, type=&quot;b&quot;) plot(x, y2, type=&quot;b&quot;) hist(y1, breaks=10) hist(y2, breaks=10) Figura 5.15: Cuatro gráficos en la misma figura con par. Se puede ver que mediante la llamada a la función par con el parámetro mfrow hemos indicado que queremos combinar cuatro gráficos dispuestos en dos filas y dos columnas. Si queremos tener un control más fino de dónde se posiciona cada figura y de su tamaño podemos utilizar el parámetro fig de la función par. Este parámetro recibe como valor un vector numérico con cuatro elementos, que permiten definir la posición y tamaño del rectángulo en el que se va a dibujar la figura de la siguiente forma: fig = c(x1, x2, y1, y2) Donde: El par (x1, y1) determina la posición de la esquina inferior izquierda del rectángulo. El valor de x2-x1 especifica el ancho del rectángulo. El valor y2-y1 especifica el alto del rectángulo. Cada uno de los cuatro elementos debe tomar un valor entre 0 y 1. Así por ejemplo, si queremos dibujar dos figuras, una en la esquina superior izquierda y otra en la esquina inferior derecha, podemos ejecutar la siguiente secuencia de expresiones en la consola de R: x&lt;-1:100 y1&lt;-log(x) y2&lt;-log(sin(x)^2) par(fig=c(0,0.6,0.5,1)) plot(x, y1, main=&quot;Función log(x)&quot;) par(fig=c(0.4,1,0,0.5), new=TRUE) plot(x, y2, main=expression(paste(&quot;Función log(&quot;,x^2,&quot;)&quot;))) Figura 5.16: Posicionando gráficos en una figura. Un aspecto que debemos tener en consideración es que al llamar a la función par con el parámetro fig se crea una nueva ventana gráfica. Si queremos dibujar varios gráficos en la misma figura debemos utilizar el parámetro new con valor TRUE, como hemos hecho en el ejemplo anterior. "],["exportando-gráficos-a-fichero.html", "5.4 Exportando gráficos a fichero", " 5.4 Exportando gráficos a fichero R nos permite exportar gráficos a ficheros con distintos formatos: pdf, png, jpeg, bmp, tiff, postscript, etc. Para guardar un gráfico debemos envolver el código que genera dicho gráfico entre una expresión inicial que indica dónde queremos guardar la información y con qué formato y una expresión final, que termina el proceso de exportación. Veamos un ejemplo: pdf(file=&quot;/path/to/salida.pdf&quot;) plot(x,y, type=&#39;b&#39;, col=&#39;blue&#39;, main=&quot;Función logaritmo&quot;) abline(h=2.5, col=&#39;red&#39;) legend(x=75,y=1,title=&quot;Leyenda&quot;,lty=1, col=c(&#39;blue&#39;,&#39;red&#39;), legend=c(&quot;Logaritmo&quot;, &quot;Referencia&quot;)) dev.off() Como se puede ver en el ejemplo anterior, comenzamos llamando a la función pdf, para indicar que queremos exportar los datos a un fichero (/path/to/salida.pdf) con formato PDF (alternativamente, podríamos haber utilizado las funciones bmp, jpeg, png, tiff o postscript). A continuación, ejecutamos las expresiones que permiten generar el gráfico que deseemos (en este caso, incluyendo una llamada a plot, una a abline y una a legend) y finalizamos ejecutando la función dev.off que cierra la ventana gráfica y termina el proceso de exportación. "],["interacción-básica-con-gráficos.html", "5.5 Interacción básica con gráficos", " 5.5 Interacción básica con gráficos Una vez dibujado un gráfico, nos puede interesar en ocasiones interactuar con él, por ejemplo, para obtener información sobre un punto concreto o etiquetarlo. Para conseguir esta funcionalidad, una vez dibujado el gráfico con plot podemos utilizar la función identify de R. Por ejemplo, supongamos que hemos realizado la siguiente representación gráfica: x&lt;-seq(1,5,0.2) y&lt;-log(sin(x)^2) plot(x,y,col=&#39;blue&#39;,type=&#39;b&#39;, ylim=c(-6,1)) Figura 5.17: Ejemplo de función con un mínimo. Queremos obtener las coordenadas de tres puntos de la función: el mínimo y los puntos donde cambia de tendencia de creciente a decreciente. Para conseguir esta información podemos ejecutar: pos&lt;-identify(x,y, plot=FALSE, n=3) Donde indicamos la secuencia de coordenadas x e y; que no queremos que se añada información al gráfico con plot=FALSE (veremos luego cómo hacer que sí se añada una etiqueta) y el número de puntos que queremos identificar (en nuestro caso tres). Tras ejecutar el comando, veremos que el terminal de R queda bloqueado a la espera de que seleccionemos los puntos en el gráfico. Para ello, haremos clic con el ratón en la figura, en los puntos de interés. Cuando hayamos alcanzado el número indicado, veremos que el terminal nos devuelve el control, y que, en la variable pos, queda almacenado el índice de los puntos seleccionados en los vectores x e y: pos # [1] 4 12 19 x[[12]] # [1] 3.2 y[[12]] # [1] -5.681764 min(y) # [1] -5.681764 Se puede ver que, efectivamente, en la posición 12 estamos obteniendo los valores x e y del mínimo. Utilizando identify, también es posible etiquetar puntos concretos. Por ejemplo, supongamos que queremos etiquetar el mínimo con la cadena de caracteres «A» y los otros dos puntos con la etiqueta «B». Entonces podemos ejecutar la secuencia de expresiones: x&lt;-seq(1,5,0.2) y&lt;-log(sin(x)^2) identify(x,y, labels=&quot;A&quot;, n=1) # Seleccionamos el mínimo con el ratón # [1] 12 identify(x,y, labels=&quot;B&quot;, n=2) # Seleccionamos los otros dos puntos # [1] 4 19 x&lt;-seq(1,5,0.2) y&lt;-log(sin(x)^2) plot(x,y,col=&#39;blue&#39;,type=&#39;b&#39;, ylim=c(-6,1)) Figura 5.18: Imagen etiquetada de manera interactiva. Un resultado similar se podría obtener utilizando identify simplemente para identificar los puntos y más tarde dibujando las etiquetas con text. Puede que en ocasiones no sepamos a priori el número de puntos a identificar. En ese caso podemos omitir el parámetro n y simplemente seleccionar lo que necesitemos, terminando la selección mediante la pulsación del botón derecho o la tecla escape (dependiendo del sistema). "],["información-extra.html", "Información extra", " Información extra Introducción a R Este documento es parte de la documentación oficial de R y ofrece una introducción al entorno y el lenguaje que cubre algunos de los aspectos tratados en este tema (y otros que veremos en temas sucesivos). Accede al artículo desde la siguiente dirección web: http://cran.r-project.org/doc/manuals/r-release/R-intro.html Cómo instalar R Este vídeo contiene un pequeño tutorial en español para instalar R en un entorno Windows, creado por personal de la Universidad Miguel Hernández de Elche. Aunque nosotros trabajaremos con una versión más reciente que la que se instala en el tutorial, el proceso de instalación no ha experimentado grandes cambios, con lo que el vídeo sigue siendo de utilidad para este curso. Accede al vídeo desde la siguiente dirección web: https://www.youtube.com/watch?v=ABrSmBE_QWI Aprendizaje del Software Estadístico R Se trata de un curso introductorio a R, elaborado por el profesor Alberto Muñoz, del Departamento de Estadística de la Universidad Carlos III de Madrid. El curso contiene materiales teóricos, actividades, lecturas recomendadas, etc. Todo ello se encuentra públicamente disponible en el repositorio OCW (Open Course Ware) de la UC3M. Accede al curso desde la siguiente dirección web: http://ocw.uc3m.es/estadistica/aprendizaje-del-software-estadistico-r-un-entorno-para-simulacion-y-computacion-estadistica RStudio RStudio es un entorno de desarrollo integrado para R, que se distribuye en dos versiones: una para escritorio (Rstudio IDE), que podemos instalar en nuestro equipo (y que cuenta con versiones gratuitas y comerciales para los principales sistemas operativos), y otra para servidores (Rstudio Server) que está pensada para ser utilizada a través un navegador. Accede a la página web desde la siguiente dirección web: https://www.rstudio.com/ A Brief History of S Se trata de un artículo en el que Richard A. Becker, uno de los creadores del lenguaje S, describe brevemente los orígenes e historia de dicho lenguaje, ofreciendo información de primera mano en aspectos tales como la motivación que les llevó al desarrollo de este lenguaje y su evolución a lo largo de los años. Becker, R. A. (s.f.). A Brief History of S. En CiteSeer. AT&amp;T Bell Laboratories. Accede a la página web desde la siguiente dirección: http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=2B5988B453B0F4298323CE7CF04715E0?doi=10.1.1.131.1428&amp;rep=rep1&amp;type=pdf R Contributed Packages Desde esta página se puede acceder al listado de los paquetes de extensión disponibles para el entorno R. Existen dos variantes del listado: una ordenada por nombre y otra por fecha de publicación. Para cada paquete el listado muestra su nombre, un enlace a su página web y una frase describiéndolo. Accede a la página web desde la siguiente dirección: http://cran.r-project.org/web/packages/ Listas de correo de R En esta página web se proporcionan los enlaces a las diferentes listas de correo de R, así como una breve descripción de la finalidad de cada una de ellas. Accede a la página web desde la siguiente dirección: http://www.r-project.org/mail.html Crantastic Dada la gran proliferación de paquetes de R para las más diversas actividades, se hace necesario poder disponer de un mecanismo de búsqueda que nos facilite encontrar paquetes que implementen una funcionalidad deseada. Esta es la motivación que llevó al desarrollo de Crantastic una herramienta web que permite buscar, etiquetar y puntuar paquetes de R. También ofrece un listado de los más populares. Accede a la página web desde la siguiente dirección: http://crantastic.org R-Bloggers R-Bloggers.com es un agregador de contenido aportado por blogueros que escriben sobre R (en inglés). El sitio ayuda a los blogueros y otros usuarios a seguir la blogosfera de R y enterarse de las últimas novedades sobre ese lenguaje. Accede a la página web desde la siguiente dirección: http://www.r-bloggers.com Intro to R Este canal consta de 21 vídeos introductorios a R (en inglés), donde se cubren aspectos tratados en este tema, y otros que veremos en temas sucesivos. Accede al canal desde la siguiente dirección web: https://www.youtube.com/playlist?list=PLOU2XLYxmsIK9qQfztXeybpHvru-TrqAP A (Not So) Short Introduction to S4 R es un lenguaje que soporta el paradigma de programación orientado a objetos. En este documento se presenta una introducción bastante completa a S4, uno de los sistemas para implementar orientación a objetos en R. Accede al documento desde la siguiente dirección web: http://cran.r-project.org/doc/contrib/Genolini-S4tutorialV0-5en.pdf The R Book Se trata de un libro bastante extenso (más de 1000 páginas) que ofrece una introducción bastante completa al lenguaje R así como a sus aplicaciones en distintos escenarios de análisis de datos. Accede a una parte del libro desde la siguiente dirección web: http://books.google.es/books?id=ccn0eLakpboC&amp;printsec=frontcover R Data Analysis tutorial En el canal, podéis encontrar una serie de vídeos en los que se introducen brevemente algunos de los aspectos cubiertos en este tema (estadística básica, importar datos desde fichero, regresión lineal, etc.). Accede al canal desde la siguiente dirección web: https://www.youtube.com/playlist?list=PLAB8D47163F188965 R DataMining.com: R and Data Mining Web dedicada por completo al uso de R como herramienta de minería de datos, donde podrás encontrar ejemplos y tutoriales sencillos sobre algunos de los aspectos cubiertos en este tema (clustering, clasificación). Accede a la página desde la siguiente dirección web: http://www.rdatamining.com/ Package «e1071» Documentación del paquete e1071, que hemos utilizado en este tema al abordar el problema de clasificación. En esta documentación podrás encontrar información acerca de las distintas funciones que componen el paquete. Accede al documento desde la siguiente dirección web: http://cran.r-project.org/web/packages/e1071/e1071.pdf An introduction to data mining Se trata de un libro que podemos consultar directamente en la web y que incluye recursos en los que se presentan, a nivel introductorio, los principales conceptos teóricos relativos a buena parte de los aspectos cubiertos en este tema (por ejemplo, incluye información sobre los tests de Chi-cuadrado y t de Student, la correlación, el algoritmo de k-means, el clasificador bayesiano ingenuo, etc.). Accede al libro desde la siguiente dirección web: http://chem-eng.utoronto.ca/~datamining/dmc/data_mining_map.htm Determining the optimal number of clusters: 3 must known methods Uno de los problemas del método de agrupamiento K-means que vimos en el tema es determinar la K (que representa el número de grupos) óptima. En el siguiente recurso se describen (en inglés) tres métodos distintos, incluyendo el método del codo. Se proporciona además código R para aplicarlos en la práctica. Accede a la página desde la siguiente dirección web: http://www.sthda.com/english/wiki/determining-the-optimal-number-of-clusters-3-must-known-methods-unsupervised-machine-learning UCI Machine Learning repository En este sitio web podrás encontrar multitud de bases de datos y ficheros con los que poder experimentar a la hora de trabajar con algoritmos de minería de datos. Entre ellos se encuentra Iris, que utilizamos en este manual. Accede a la página web desde la siguiente dirección: https://archive.ics.uci.edu/ml/index.html Producing Simple Graphs with R Se trata de un tutorial práctico (en inglés) en el que se presentan los principales tipos de gráficos de R. Para cada tipo se incluye un ejemplo que se va desarrollando paso a paso, ofreciendo tanto el código de R como la imagen del gráfico resultante en cada etapa. Accede al tutorial desde la siguiente dirección web: https://www.harding.edu/fmccown/r/ Introduction to R graphics with ggplot2 En este tema nos hemos centrado en el sistema gráfico que R incorpora por defecto, sin embargo, existen también paquetes de extensión específicamente diseñados para facilitar la representación gráfica de datos. En esta referencia podéis encontrar un pequeño tutorial (en inglés) en el que se describe uno de los paquetes gráficos más ampliamente utilizados: ggplot2. Accede al documento desde la siguiente dirección web: http://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html Introduction to the tm package. Text mining in R Un pequeño tutorial de 8 páginas en las que el autor del paquete tm presenta algunas funcionalidades básicas del mismo. Con respecto a lo presentado en este tema, resulta de interés la sección relativa a gestión de metadatos de corpus y documentos (que no hemos tratado aquí). Accede al tutorial desde la siguiente dirección web: http://cran.r-project.org/web/packages/tm/vignettes/tm.pdf The igraph software package Se trata de un pequeño artículo en el que se ofrece una introducción a la librería igraph, describiendo a nivel general algunas de sus principales funcionalidades y presentando posibles escenarios de uso. Csardi, G y Nepusz, T. (2006). The igraph software package for complex network research. Inter Journal, 1695. Accede al artículo desde la siguiente dirección web: http://www.necsi.edu/events/iccs6/papers/c1602a3c126ba822d0bc4293371c.pdf Aplicaciones de la teoría de grafos a la vida real Se trata de una colección bastante extensa de pequeños tutoriales elaborados por personal de la Universidad Politécnica de Valencia en los que se tratan distintos aspectos de la teoría de grafos y sus aplicaciones a escenarios de la vida cotidiana. Accede al vídeo desde la siguiente dirección web: https://www.youtube.com/playlist?list=PL6kQim6ljTJu44dsVeZifHHiuDC1MEZ7q Stanford Large Network Dataset Collection Desde esta página se pueden descargar ficheros que contienen ejemplos de grafos obtenidos de diversas fuentes y supone una fuente interesante en la que encontrar datos sobre los que poder llevar a cabo un análisis. Accede a la página web a través de la siguiente dirección: http://snap.stanford.edu/dat R in action R in Action le brinda una introducción guiada a R, que le brinda una vista de 2,000 pies de la plataforma y sus capacidades. Le presentará las funciones más importantes de la instalación base y más de 90 de los paquetes contribuidos más útiles. A lo largo del libro, el objetivo es la aplicación práctica: cómo puede dar sentido a sus datos y comunicar ese entendimiento a los demás. Kabacoff, R. (2011). R in action. Nueva York: Editorial Manning. Accede al libro a través de la siguiente dirección: http://www.cs.uni.edu/~jacobson/4772/week11/R_in_Action.pdf Bibliografía complementaria Newman, M. E. J. (2010). Networks: An introduction. Oxford: Oxford University Press. Kabacoff, R. (2011). R in action. Nueva York: Editorial Manning. Dalgaard, P. (2004). Introductory Statistics with R. Copenhague: Springer. Matloff, N. (2011). The Art of R Programming: A Tour of Statistical Software Design. California: No Starch Press. Teetor, P. (2011). R Cookbook. California: OReilly. Kolaczyk, E. &amp; Csárdi, G. (2014). Statistical Analysis of Network Data with R. Springer. Wilkinson, L. (2005). The Grammar of Graphics. Springer. Russell, M. A. (2013). Mining the Social Web. California: OReilly Media. Weiss, S. M., Indurkhya, N., Zhang, T., Damerau, F. (2005).Text Mining. Springer. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
